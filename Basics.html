

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction &mdash; amrex 10.17 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="amrex 10.17 documentation" href="index.html"/>
        <link rel="up" title="Basics" href="Chapter4.html"/>
        <link rel="next" title="Boundary Conditions" href="Boundary.html"/>
        <link rel="prev" title="Basics" href="Chapter4.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                10.17
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter2.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Building AMReX</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Chapter4.html">Basics</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#heatequation-ex1-c-example">HeatEquation_EX1_C Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dimensionality">Dimensionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array">Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="#real">Real</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paralleldescriptor">ParallelDescriptor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#print">Print</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parmparse">ParmParse</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-amr-grids">Example of AMR Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="#box-intvect-and-indextype">Box, IntVect and IndexType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intvect">IntVect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indextype">IndexType</a></li>
<li class="toctree-l3"><a class="reference internal" href="#box">Box</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#realbox-and-geometry">RealBox and Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boxarray">BoxArray</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distributionmapping">DistributionMapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basefab-farraybox-and-iarraybox">BaseFab, FArrayBox and IArrayBox</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fabarray-multifab-and-imultifab">FabArray, MultiFab and iMultiFab</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mfiter-and-tiling">MFIter and Tiling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-without-tiling">MFIter without Tiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-with-tiling">MFIter with Tiling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calling-fortran-or-c">Calling Fortran or C</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ghost-cells">Ghost Cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i-o">I/O</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plotfile">Plotfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checkpoint-file">Checkpoint File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocation">Memory Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abort-and-assertion">Abort and Assertion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Boundary.html">Boundary Conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Amr.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="CVODE.html">CVODE</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Chapter4.html">Basics</a> &raquo;</li>
        
      <li>Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>In this chapter, we present the basics of AMReX. The implementation
source codes are in amrex/Src/Base/. Note that &nbsp;classes
and functions are in namespace amrex. For clarity, we usually
drop amrex:: in the example codes here. It is also assumed that
headers have been properly included. We recommend you study
the tutorial in amrex/Tutorials/Basic/HeatEquation_EX1_C while reading this chapter.
After reading this chapter, one should be able to develop single-level
parallel codes using . It should also be noted that this is not
a comprehensive reference manual.</p>
</div>
<div class="section" id="heatequation-ex1-c-example">
<h1>HeatEquation_EX1_C Example<a class="headerlink" href="#heatequation-ex1-c-example" title="Permalink to this headline">¶</a></h1>
<p>The source code tree for the heat equation example is simple, as shown
in Figure 4.1. We recommend you study
main.cpp and advance.cpp to see some of the classes described
below in action.</p>
<div class="figure" id="id1">
<a class="reference internal image-reference" href="../Basics/figs/flowchart.png"><img alt="../Basics/figs/flowchart.png" src="../Basics/figs/flowchart.png" style="width: 4.00000in;" /></a>
<p class="caption"><span class="caption-text">Figure 4.1:  Source code tree for the
HeatEquation_EX1_C example.</span></p>
</div>
<ul>
<li><div class="first line-block">
<div class="line">Base/</div>
<div class="line">Contains source code for single-level simulations.</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">HeatEquation_EX1_C</div>
<div class="line">Build the code here by editing the GNUmakefile and running make.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="dimensionality">
<h1>Dimensionality<a class="headerlink" href="#dimensionality" title="Permalink to this headline">¶</a></h1>
<p>As we have mentioned in Chapter&nbsp;[Chap:BuildingAMReX], the
dimensionality of &nbsp;must be set at compile time. A macro, AMREX_SPACEDIM, is defined to be the number of spatial
dimensions. C++ codes can also use the amrex::SpaceDim
variable. Fortran codes can use either the macro and preprocessing or
do</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_spacedim</span>
</pre></div>
</div>
<p>The coordinate directions are zero based.</p>
</div>
<div class="section" id="array">
<h1>Array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h1>
<p>Array class in AMReX_Array.H is derived from std::vector. The only difference between Array and std::vector is that Array::operator[] provides bound checking
when compiled with DEBUG=TRUE.</p>
</div>
<div class="section" id="real">
<h1>Real<a class="headerlink" href="#real" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;can be compiled to use either double precision (which is the
default) or single precision. amrex::Real is typedef’d to
either double or float. C codes can use amrex_real. They are defined in AMReX_REAL.H. The data
type is accessible in Fortran codes via</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
</pre></div>
</div>
</div>
<div class="section" id="paralleldescriptor">
<h1>ParallelDescriptor<a class="headerlink" href="#paralleldescriptor" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;users do not need to use MPI directly. Parallel communication
is often handled by the data abstraction classes (e.g., MultiFab; Section&nbsp;[sec:basics:multifab]). In addition, has provided namespace ParallelDescriptor in &lt;AMReX_ParallelDescriptor.H&gt;. The frequently used functions are</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">myproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">MyProc</span><span class="p">();</span>  <span class="o">//</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">rank</span>

<span class="nb">int</span> <span class="n">nprocs</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">NProcs</span><span class="p">();</span>  <span class="o">//</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">processes</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">IOProcessor</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Only</span> <span class="n">the</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">process</span> <span class="n">executes</span> <span class="n">this</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">ioproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">IOProcessorNumber</span><span class="p">();</span>  <span class="o">//</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">rank</span>

<span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">Barrier</span><span class="p">();</span>

<span class="o">//</span> <span class="n">Broadcast</span> <span class="mi">100</span> <span class="n">ints</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">Processor</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">Bcast</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span>
                    <span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">IOProcessorNumber</span><span class="p">())</span>

<span class="o">//</span> <span class="n">See</span> <span class="n">AMReX_ParallelDescriptor</span><span class="o">.</span><span class="n">H</span> <span class="k">for</span> <span class="n">many</span> <span class="n">other</span> <span class="n">Reduce</span> <span class="n">functions</span>
<span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">ReduceRealSum</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="print">
<h1>Print<a class="headerlink" href="#print" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;provides classes in AMReX_Print.H for printing messages
to standard output or any &nbsp;ostream. The main reason one
should use them instead of std::cout is that messages from
multiple processes or threads do not get mixed up. Below are some
examples.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span>  <span class="s2">&quot;x = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> <span class="o">//</span> <span class="n">Print</span> <span class="n">on</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">processor</span>

<span class="n">Real</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="mf">4.0</span><span class="p">;</span>
<span class="o">//</span> <span class="n">Print</span> <span class="n">on</span> <span class="n">rank</span> <span class="mi">3</span> <span class="k">with</span> <span class="n">precision</span> <span class="n">of</span> <span class="mi">17</span> <span class="n">digits</span>
<span class="o">//</span> <span class="n">SetPrecision</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">modify</span> <span class="n">cout</span><span class="s1">&#39;s floating-point decimal precision setting.</span>
<span class="n">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">SetPrecision</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">oldprec</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Print</span> <span class="k">with</span> <span class="mi">10</span> <span class="n">digits</span>

<span class="n">AllPrint</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Every process prints</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Print</span> <span class="n">on</span> <span class="n">every</span> <span class="n">process</span>

<span class="n">std</span><span class="p">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s2">&quot;my.txt&quot;</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">ofstream</span><span class="p">::</span><span class="n">out</span><span class="p">);</span>
<span class="n">Print</span><span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Print to a file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">ofs</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="parmparse">
<h1>ParmParse<a class="headerlink" href="#parmparse" title="Permalink to this headline">¶</a></h1>
<p>ParmParse in AMReX_ParmParse.H is a class providing a
database for the storage and retrieval of command-line and input-file
arguments. When amrex::Initialize() is called, the first
command-line argument after the executable name (if there is one and
it does not contain character =) is taken to be the inputs file,
and the contents in the file are used to initialize the ParmParse database. The rest of the command-line arguments are
also parsed by ParmParse. The format of the inputs file is a
series of definitions in the form of prefix.name = value value
…. For each line, texts after # are comments. Here is an
example inputs file.</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">100</span>               <span class="c1"># integer</span>
<span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">1000</span>              <span class="c1"># nsteps appears a second time</span>
<span class="n">dt</span>        <span class="o">=</span> <span class="mf">0.03</span>              <span class="c1"># floating point number</span>
<span class="n">ncells</span>    <span class="o">=</span> <span class="mi">128</span> <span class="mi">64</span> <span class="mi">32</span>         <span class="c1"># a list of 3 ints</span>
<span class="n">xrange</span>    <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="mf">0.5</span>          <span class="c1"># a list of 2 reals</span>
<span class="n">title</span>     <span class="o">=</span> <span class="s2">&quot;Three Kingdoms&quot;</span>  <span class="c1"># a string</span>
<span class="n">hydro</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="mf">0.8</span>               <span class="c1"># with prefix, hydro</span>
</pre></div>
</div>
</div></blockquote>
<p>The following code shows how to use ParmParse to get/query the values.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ParmParse pp;

int nsteps = 0;
pp.query(&quot;nsteps&quot;, nsteps);
amrex::Print() &lt;&lt; nsteps &lt;&lt; &quot;\n&quot;;  // 1000

Real dt;
pp.get(&quot;dt&quot;, dt);  // runtime error if dt is not in inputs

Vector&lt;int&gt; numcells;
// The variable name &#39;numcells&#39; can be different from parameter name &#39;ncells&#39;.
pp.getarr(&quot;ncells&quot;, numcells);
amrex::Print() &lt;&lt; numcells.size() &lt;&lt; &quot;\n&quot;;  // 3

Vector&lt;Real&gt; xr {-1.0, 1.0};
if (!queryarr(&quot;xrange&quot;, xr)) {
    amrex::Print() &lt;&lt; &quot;Cannot find xrange in inputs, &quot;
                   &lt;&lt; &quot;so the default {-1.0,1.0} will be used\n&quot;;
}

std::string title;
pp.query(&quot;title&quot;, title);  // query string

ParmParse pph(&quot;hydro&quot;);  // with prefix &#39;hydro&#39;
Real cfl;
pph.get(&quot;cfl&quot;, cfl);    // get parameter with prefix
</pre></div>
</div>
<p>Note that when there are multiple definitions for a parameter ParmParse by default returns the last one. The difference between
query and get should also be noted. It is a runtime error
if get fails to get the value, whereas query returns an
error code without generating a runtime error that will abort the run.
If it is sometimes convenient to override parameters with command-line
arguments without modifying the inputs file. The command-line
arguments after the inputs file are added later than the file to the
database and are therefore used by default. For example, one can run
with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">myexecutable</span> <span class="n">myinputsfile</span> <span class="n">ncells</span><span class="o">=</span><span class="s2">&quot;64 32 16&quot;</span> <span class="n">hydro</span><span class="o">.</span><span class="n">cfl</span><span class="o">=</span><span class="mf">0.9</span>
</pre></div>
</div>
<p>to change the value of ncells and hydro.cfl.</p>
</div>
<div class="section" id="example-of-amr-grids">
<h1>Example of AMR Grids<a class="headerlink" href="#example-of-amr-grids" title="Permalink to this headline">¶</a></h1>
<p>In block-structured AMR, there is a hierarchy of logically rectangular
grids. The computational domain on each AMR level is decomposed into
a union of rectangular domains. Figure&nbsp;4.2
shows an example of AMR grids. There are three total levels in the
example. In &nbsp;numbering convention, the coarsest level is level
0. The coarsest grid (<em>black</em>) covers the domain with <span class="math">\(16^2\)</span>
cells. Bold lines represent grid boundaries. There are two
intermediate resolution grids (<em>blue</em>) at level 1 and the
cells are a factor of two finer than those at level 0. The two finest
grids (<em>red</em>) are at level 2 and the cells are a factor of two
finer than the level 1 cells. Note that there is no direct
parent-child connection. In this chapter, we will focus on single
levels.</p>
<div class="figure" id="id2">
<a class="reference internal image-reference" href="../Basics/amrgrids.png"><img alt="../Basics/amrgrids.png" src="../Basics/amrgrids.png" style="width: 3.00000in;" /></a>
<p class="caption"><span class="caption-text">Figure 4.2: Example of AMR grids. There are
three levels in total. There are 1, 2 and 2 Boxes on levels
0, 1, and 2, respectively.</span></p>
</div>
</div>
<div class="section" id="box-intvect-and-indextype">
<h1>Box, IntVect and IndexType<a class="headerlink" href="#box-intvect-and-indextype" title="Permalink to this headline">¶</a></h1>
<p>Box in AMReX_Box.H is the data structure for representing
a rectangular domain in indexing space. For example, in
Figure&nbsp;4.2, there are 1, 2 and 2 Boxes on
levels 0, 1 and 2, respectively. Box is a dimension dependent
class. It has lower and upper corners (represented by IntVect
and an index type (represented by IndexType). There are no
floating-point data in the object.</p>
<div class="section" id="intvect">
<h2>IntVect<a class="headerlink" href="#intvect" title="Permalink to this headline">¶</a></h2>
<p>is a dimension dependent class representing an
integer vector in -dimensional space. An
IntVect can be constructed as follows,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="n">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Here AMREX_D_DECL is a macro that expands AMREX_D_DECL(19,0,5) to either 19 or 19,0 or 19,0,5 depending on the number of dimensions. The data can be
accessed via operator[], and the internal data pointer can be
returned by function getVect. For example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">idim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">amrex</span><span class="p">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;iv[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">idim</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;] = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">const</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">iv</span><span class="o">.</span><span class="n">getVect</span><span class="p">();</span>  <span class="o">//</span> <span class="n">This</span> <span class="n">can</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">Fortran</span><span class="o">/</span><span class="n">C</span> <span class="k">as</span> <span class="n">an</span> <span class="n">array</span>
</pre></div>
</div>
<p>The class has a static function TheZeroVector() returning the
zero vector, TheUnitVector() returning the unit vector, and TheDimensionVector (int dir) returning a reference to a constant
IntVect that is zero except in the dir-direction. Note
the direction is zero-based. IntVect has a number of relational
operators, ==, !=, , and &gt;= that can be used for lexicographical comparison (e.g., key of
std::map), and a class IntVect::shift_hasher that can be
used as a hash function (e.g., for std::unordered_map). It
also has various arithmetic operators. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="n">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="n">iv2</span><span class="p">((</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="n">iv</span> <span class="o">+=</span> <span class="n">iv2</span><span class="p">;</span>  <span class="o">//</span> <span class="n">iv</span> <span class="ow">is</span> <span class="n">now</span> <span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">iv</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>    <span class="o">//</span> <span class="n">iv</span> <span class="ow">is</span> <span class="n">now</span> <span class="p">(</span><span class="mi">46</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>In AMR codes, one often needs to do refinement and coarsening on IntVect. The refinement operation can be done with the
multiplication operation. However, the coarsening requires care
because of the rounding towards zero behavior of integer division in
Fortran, C and C++. For example int i = -1/2 gives i =
0, and what we want is usually i = -1. Thus, one should use
the coarsen functions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="n">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="n">coarsening_ratio</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">iv</span><span class="o">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>                 <span class="o">//</span> <span class="n">Coarsen</span> <span class="n">each</span> <span class="n">component</span> <span class="n">by</span> <span class="mi">2</span>
<span class="n">iv</span><span class="o">.</span><span class="n">coarsen</span><span class="p">(</span><span class="n">coarsening_ratio</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Component</span><span class="o">-</span><span class="n">wise</span> <span class="n">coarsening</span>
<span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">iv2</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="o">//</span> <span class="n">Return</span> <span class="n">an</span> <span class="n">IntVect</span> <span class="n">w</span><span class="o">/</span><span class="n">o</span> <span class="n">modifying</span> <span class="n">iv</span>
<span class="n">IntVect</span> <span class="n">iv3</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">coarsening_return</span><span class="p">);</span> <span class="o">//</span> <span class="n">iv</span> <span class="ow">not</span> <span class="n">modified</span>
</pre></div>
</div>
<p>Finally, we note that operator&lt;&lt; is overloaded for IntVect and therefore one can call</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">amrex</span><span class="p">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="indextype">
<h2>IndexType<a class="headerlink" href="#indextype" title="Permalink to this headline">¶</a></h2>
<p>This class defines an index as being cell based or node based in
each dimension. The default constructor defines a cell based type in
all directions. One can also construct an IndexType with an
IntVect with zero and one representing cell and node,
respectively.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Node</span> <span class="ow">in</span> <span class="n">x</span><span class="o">-</span><span class="n">direction</span> <span class="ow">and</span> <span class="n">cell</span> <span class="n">based</span> <span class="ow">in</span> <span class="n">y</span> <span class="ow">and</span> <span class="n">z</span><span class="o">-</span><span class="n">directions</span>
<span class="o">//</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">face</span> <span class="n">of</span> <span class="n">numerical</span> <span class="n">cells</span><span class="p">)</span>
<span class="n">IndexType</span> <span class="n">xface</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)});</span>
</pre></div>
</div>
<p>The class provides various functions including</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">the</span> <span class="n">IndexType</span> <span class="ow">is</span> <span class="n">cell</span> <span class="n">based</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">directions</span><span class="o">.</span>
<span class="nb">bool</span> <span class="n">cellCentered</span> <span class="p">()</span> <span class="n">const</span><span class="p">;</span>

<span class="o">//</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">the</span> <span class="n">IndexType</span> <span class="ow">is</span> <span class="n">cell</span> <span class="n">based</span> <span class="ow">in</span> <span class="nb">dir</span><span class="o">-</span><span class="n">direction</span><span class="o">.</span>
<span class="nb">bool</span> <span class="n">cellCentered</span> <span class="p">(</span><span class="nb">int</span> <span class="nb">dir</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

<span class="o">//</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">the</span> <span class="n">IndexType</span> <span class="ow">is</span> <span class="n">node</span> <span class="n">based</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">directions</span><span class="o">.</span>
<span class="nb">bool</span> <span class="n">nodeCentered</span> <span class="p">()</span> <span class="n">const</span><span class="p">;</span>

<span class="o">//</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">the</span> <span class="n">IndexType</span> <span class="ow">is</span> <span class="n">node</span> <span class="n">based</span> <span class="ow">in</span> <span class="nb">dir</span><span class="o">-</span><span class="n">direction</span><span class="o">.</span>
<span class="nb">bool</span> <span class="n">nodeCentered</span> <span class="p">(</span><span class="nb">int</span> <span class="nb">dir</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Index type is a very important concept in . It is a way of
representing the notion of indices <span class="math">\(i\)</span> and <span class="math">\(i+1/2\)</span>.</p>
</div>
<div class="section" id="box">
<h2>Box<a class="headerlink" href="#box" title="Permalink to this headline">¶</a></h2>
<p>A Box is an abstraction for defining discrete regions of AMREX_SPACEDIM-dimensional indexing space. Boxes have an
IndexType and two IntVects representing the lower and
upper corners. Boxes can exist in positive and negative indexing
space. Typical ways of defining a Box are</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="n">lo</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="n">hi</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IndexType</span> <span class="n">typ</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)});</span>
<span class="n">Box</span> <span class="n">cc</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">);</span>        <span class="o">//</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="n">Box</span> <span class="ow">is</span> <span class="n">cell</span> <span class="n">based</span><span class="o">.</span>
<span class="n">Box</span> <span class="n">nd</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">typ</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Construct</span> <span class="n">a</span> <span class="n">nodal</span> <span class="n">Box</span><span class="o">.</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;A cell-centered Box &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;An all nodal Box    &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nd</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Depending the dimensionality, the output of the code above is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">cell</span><span class="o">-</span><span class="n">centered</span> <span class="n">Box</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">An</span> <span class="nb">all</span> <span class="n">nodal</span> <span class="n">Box</span>    <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For simplicity, we will assume it is 3D for the rest of this section.
In the output, three integer tuples for each box are the lower corner
indices, upper corner indices, and the index types. Note that 0
and 1 denote cell and node, respectively. For each tuple like
(64,64,64), the 3 numbers are for 3 directions. The two Boxes in the code above represent different indexing views of the
same domain of <span class="math">\(64^3\)</span> cells. Note that in &nbsp;convention, the
lower side of a cell has the same integer value as the cell centered
index. That is if we consider a cell based index represent <span class="math">\(i\)</span>, the
nodal index with the same integer value represents <span class="math">\(i-1/2\)</span>.
Figure&nbsp;4.3 shows a 2D example of various index
types.</p>
<div class="figure" id="id3">
<a class="reference internal image-reference" href="../Basics/indextypes.png"><img alt="../Basics/indextypes.png" src="../Basics/indextypes.png" style="width: 5.00000in;" /></a>
<p class="caption"><span class="caption-text">Figure 4.3: Some of the different index
types in two dimensions: (a) cell-centered, (b) <span class="math">\(x\)</span>-face-centered
(i.e., nodal in <span class="math">\(x\)</span>-direction only), and (c) corner/nodal,
i.e., nodal in all dimensions.</span></p>
</div>
<p>There are a number of ways of converting a Box from one type to
another.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">b0</span> <span class="p">({</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">},</span> <span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span> <span class="o">//</span> <span class="n">Index</span> <span class="nb">type</span><span class="p">:</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>

<span class="n">Box</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b0</span><span class="p">);</span>  <span class="o">//</span> <span class="n">A</span> <span class="n">new</span> <span class="n">Box</span> <span class="k">with</span> <span class="nb">type</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b1</span><span class="p">;</span>                  <span class="o">//</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b0</span><span class="p">;</span>                  <span class="o">//</span> <span class="n">Still</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="n">Box</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">enclosedCells</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>     <span class="o">//</span> <span class="n">A</span> <span class="n">new</span> <span class="n">Box</span> <span class="k">with</span> <span class="nb">type</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">b2</span> <span class="o">==</span> <span class="n">b0</span><span class="p">)</span> <span class="p">{</span>                 <span class="o">//</span> <span class="n">Yes</span><span class="p">,</span> <span class="n">they</span> <span class="n">are</span> <span class="n">identical</span><span class="o">.</span>
   <span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;b0 and b2 are identical!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Box</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>  <span class="o">//</span> <span class="n">A</span> <span class="n">new</span> <span class="n">Box</span> <span class="k">with</span> <span class="nb">type</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="o">//</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="n">b3</span><span class="o">.</span><span class="n">convert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>            <span class="o">//</span> <span class="n">Convert</span> <span class="n">b0</span> <span class="n">to</span> <span class="nb">type</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="o">//</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">b3</span><span class="o">.</span><span class="n">surroundingNodes</span><span class="p">();</span>          <span class="o">//</span>  <span class="n">Exercise</span> <span class="k">for</span> <span class="n">you</span>
<span class="n">b3</span><span class="o">.</span><span class="n">enclosedCells</span><span class="p">();</span>             <span class="o">//</span>  <span class="n">Exercise</span> <span class="k">for</span> <span class="n">you</span>
</pre></div>
</div>
<p>The internal data of Box can be accessed via various member functions.
Examples are</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">smallEnd</span> <span class="p">()</span> <span class="n">const</span><span class="o">&amp;</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">small</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Box</span>
<span class="nb">int</span> <span class="n">bigEnd</span> <span class="p">(</span><span class="nb">int</span> <span class="nb">dir</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>         <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">big</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">dir</span> <span class="n">direction</span>
<span class="n">const</span> <span class="nb">int</span><span class="o">*</span> <span class="n">loVect</span> <span class="p">()</span> <span class="n">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="o">//</span> <span class="n">Get</span> <span class="n">a</span> <span class="n">const</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">lower</span> <span class="n">end</span>
<span class="n">const</span> <span class="nb">int</span><span class="o">*</span> <span class="n">hiVect</span> <span class="p">()</span> <span class="n">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="o">//</span> <span class="n">Get</span> <span class="n">a</span> <span class="n">const</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">upper</span> <span class="n">end</span>
</pre></div>
</div>
<p>Boxes can be refined and coarsened. Refinement or coarsening
does not change the index type. Some examples are shown below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Box ccbx ({16,16,16}, {31,31,31});
ccbx.refine(2);
Print() &lt;&lt; ccbx;                   // ((32,32,32) (63,63,63) (0,0,0))
Print() &lt;&lt; ccbx.coarsen(2);        // ((16,16,16) (31,31,31) (0,0,0))

Box ndbx ({16,16,16}, {32,32,32}, {1,1,1});
ndbx.refine(2);
Print() &lt;&lt; ndbx;                   // ((32,32,32) (64,64,64) (1,1,1))
Print() &lt;&lt; ndbx.coarsen(2);        // ((16,16,16) (32,32,32) (1,1,1))

Box facebx ({16,16,16}, {32,31,31}, {1,0,0});
facebx.refine(2);
Print() &lt;&lt; facebx;                 // ((32,32,32) (64,63,63) (1,0,0))
Print() &lt;&lt; facebx.coarsen(2);      // ((16,16,16) (32,31,31) (1,0,0))

Box uncoarsenable ({16,16,16}, {30,30,30});
print() &lt;&lt; uncoarsenable.coarsen(2); // ({8,8,8}, {15,15,15});
print() &lt;&lt; uncoarsenable.refine(2);  // ({16,16,16}, {31,31,31});
                                     // Different from the original!
</pre></div>
</div>
<p>Note that refinement and coarsening behaviors depend on the indexing
type. One should think the refinement and coarsening in AMR context
that refined or coarsened Box still covers the same physical
domain. Box uncoarsenable in the example above is considered
uncoarsenable because its coarsened version does not cover the same
physical domain in the AMR context.</p>
<p>Boxes can grow and they can grow in all directions or just one
direction. There are a number of grow functions. Some are
member functions of the Box class and others are non-member
functions in the amrex namespace.</p>
<p>Box class provides the following member functions testing if a Box or IntVect is contained within this Box. Note that
it is a runtime error if the two Boxes have different types.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">contains</span> <span class="p">(</span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="nb">bool</span> <span class="n">strictly_contains</span> <span class="p">(</span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="nb">bool</span> <span class="n">contains</span> <span class="p">(</span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="nb">bool</span> <span class="n">strictly_contains</span> <span class="p">(</span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Another very common operation is the intersection of two Boxes
like in the following examples.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Box b0 ({16,16,16}, {31,31,31});
Box b1 ({ 0, 0,30}, {23,23,63});
if (b0.intersects(b1)) {                  // true
    Print() &lt;&lt; &quot;b0 and b1 intersect.\n&quot;;
}

Box b2 = b0 &amp; b1;     // b0 and b1 unchanged
Print() &lt;&lt; b2;        // ((16,16,30) (23,23,31) (0,0,0))

Box b3 = surroundingNodes(b0) &amp; surroundingNodes(b1); // b0 and b1 unchanged
Print() &lt;&lt; b3;        // ((16,16,30) (24,24,32) (1,1,1))

b0 &amp;= b2;             // b2 unchanged
Print() &lt;&lt; b0;        // ((16,16,30) (23,23,31) (0,0,0))

b0 &amp;= b3;             // Runtime error because of type mismatch!
</pre></div>
</div>
</div>
</div>
<div class="section" id="realbox-and-geometry">
<h1>RealBox and Geometry<a class="headerlink" href="#realbox-and-geometry" title="Permalink to this headline">¶</a></h1>
<p>A RealBox stores the physical location in floating-point numbers
of the lower and upper corners of a rectangular domain.</p>
<p>Geometry class in AMReX_Geometry.H describes problem
domain and coordinate system for rectangular problem domains. A Geometry object can be constructed with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">explicit</span> <span class="n">Geometry</span> <span class="p">(</span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span>     <span class="n">dom</span><span class="p">,</span>
                   <span class="n">const</span> <span class="n">RealBox</span><span class="o">*</span> <span class="n">rb</span>     <span class="o">=</span> <span class="n">nullptr</span><span class="p">,</span>
                   <span class="nb">int</span>            <span class="n">coord</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="nb">int</span><span class="o">*</span>           <span class="n">is_per</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the constructor takes a cell-centered Box specifying the
indexing space domain, an optional argument of RealBox pointer
specifying the physical domain, an optional int specifying
coordinate system type, and an optional int* specifying
periodicity. If a RealBox is not given, &nbsp;will construct
one based on ParmParse parameters, geometry.prob_lo and
geometry.prob_hi, where each of the parameter is an array of
AMREX_SPACEDIM real numbers. It’s a runtime error if this
fails. The optional argument for coordinate system is an integer type
with valid values being 0 (Cartesian), or 1 (cylindrical), or 2
(spherical). If it is invalid as in the case of the default argument
value, &nbsp;will query the ParmParse database for geometry.coord_sys and use it if one is found. If it cannot find
the parameter, the coordinate system is set to 0 (i.e., Cartesian
coordinates). Geometry class has the concept of periodicity.
An optional argument can be passed specifying periodicity in each
dimension. If it is not given, the domain is assumed to be
non-periodic unless there is the ParmParse integer array
parameter geometry.is_periodic with 0 denoting
non-periodic and 1 denoting periodic. Below is an example of
defining a Geometry for a periodic rectangular domain of
<span class="math">\([-1.0,1.0]\)</span> in each direction discretized with <span class="math">\(64\)</span> numerical cells
in each direction.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">n_cell</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">Box</span> <span class="k">with</span> <span class="n">n_cell</span> <span class="n">cells</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">direction</span><span class="o">.</span>
<span class="n">Box</span> <span class="n">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">)},</span>
           <span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">)});</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">defines</span> <span class="n">the</span> <span class="n">physical</span> <span class="n">box</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">direction</span><span class="o">.</span>
<span class="n">RealBox</span> <span class="n">real_box</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)},</span>
                 <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)});</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">says</span> <span class="n">we</span> <span class="n">are</span> <span class="n">using</span> <span class="n">Cartesian</span> <span class="n">coordinates</span>
<span class="nb">int</span> <span class="n">coord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">sets</span> <span class="n">the</span> <span class="n">boundary</span> <span class="n">conditions</span> <span class="n">to</span> <span class="n">be</span> <span class="n">doubly</span> <span class="ow">or</span> <span class="n">triply</span> <span class="n">periodic</span>
<span class="n">std</span><span class="p">::</span><span class="n">array</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">is_periodic</span> <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)};</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">Geometry</span> <span class="nb">object</span>
<span class="n">Geometry</span> <span class="n">geom</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_box</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">is_periodic</span><span class="o">.</span><span class="n">data</span><span class="p">());</span>
</pre></div>
</div>
<p>A Geometry object can return various information of the physical
domain and the indexing space domain. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>const Real* problo = geom.ProbLo();    // Lower corner of the physical domain
Real yhi = geom.ProbHi(1);             // y-direction upper corner
const Real* dx = geom.CellSize();      // Cell size for each direction
const Box&amp; domain = geom.Domain();     // Index domain
bool is_per = Geometry::isPeriodic(0); // Is periodic in x-direction?
if (Geometry::isAllPeriodic()) {}      // Periodic in all direction?
if (Geometry::isAnyPeriodic()) {}      // Periodic in any direction?
</pre></div>
</div>
</div>
<div class="section" id="boxarray">
<h1>BoxArray<a class="headerlink" href="#boxarray" title="Permalink to this headline">¶</a></h1>
<p>BoxArray is a class in AMReX_BoxArray.H for storing a
collection of Boxes on a single AMR level. One can make a BoxArray out of a single Box and then chop it into multiple
Boxes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span>
<span class="n">BoxArray</span> <span class="n">ba</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Make</span> <span class="n">a</span> <span class="n">new</span> <span class="n">BoxArray</span> <span class="n">out</span> <span class="n">of</span> <span class="n">a</span> <span class="n">single</span> <span class="n">Box</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;BoxArray size is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="mi">1</span>
<span class="n">ba</span><span class="o">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>       <span class="o">//</span> <span class="n">Chop</span> <span class="n">into</span> <span class="n">boxes</span> <span class="n">of</span> <span class="mi">64</span><span class="o">^</span><span class="mi">3</span> <span class="n">cells</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is like below,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">BoxArray</span> <span class="n">maxbox</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
       <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">m_hash_sig</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>It shows that ba now has 8 Boxes, and it also prints out
each Box.</p>
<p>In , BoxArray is a global data structure. It holds all
the Boxes in a collection, even though a single process in a
parallel run only owns some of the Boxes via domain
decomposition. In the example above, a 4-process run may divide the
work and each process owns say 2 Boxes
(Section&nbsp;[sec:basics:dm]). Each process can then allocate memory
for the floating point data on the Boxes it owns
(Sections&nbsp;[sec:basics:multifab] &amp; [sec:basics:fab]).</p>
<p>BoxArray has an indexing type, just like Box. Each Box in a BoxArray has the same type as the BoxArray
itself. In the following example, we show how one can convert BoxArray to a different type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="n">cellba</span><span class="p">(</span><span class="n">Box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">}));</span>
<span class="n">cellba</span><span class="o">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="n">BoxArray</span> <span class="n">faceba</span> <span class="o">=</span> <span class="n">cellba</span><span class="p">;</span>       <span class="o">//</span> <span class="n">Make</span> <span class="n">a</span> <span class="n">copy</span>
<span class="n">faceba</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span> <span class="o">//</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">index</span> <span class="nb">type</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
<span class="o">//</span> <span class="n">Return</span> <span class="n">an</span> <span class="nb">all</span> <span class="n">node</span> <span class="n">BoxArray</span>
<span class="n">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">nodeba</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">convert</span><span class="p">(</span><span class="n">faceba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">cellba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">faceba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nodeba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>As shown in the example above, BoxArray has an operator[]
that returns a Box given an index. It should be emphasized that
there is a difference between its behavior and the usual behavior of
an subscript operator one might expect. The subscript operator in
BoxArray returns by value instead of reference. This means code
like below is meaningless because it modifies a temporary return
value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ba[3].coarsen(2);  // DO NOT DO THIS!  Doesn&#39;t do what one might expect.
</pre></div>
</div>
<p>BoxArray has a number of member functions that allow the Boxes to be modified. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">refine</span> <span class="p">(</span><span class="nb">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>   <span class="o">//</span> <span class="n">Refine</span> <span class="n">each</span> <span class="n">Box</span> <span class="ow">in</span> <span class="n">BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">refine</span> <span class="p">(</span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">coarsen</span> <span class="p">(</span><span class="nb">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Coarsen</span> <span class="n">each</span> <span class="n">Box</span> <span class="ow">in</span> <span class="n">BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">coarsen</span> <span class="p">(</span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>We have mentioned at the beginning of this section that BoxArray
is a global data structure storing Boxes shared by all processes.
The operation of a deep copy is thus undesirable because it
is expensive and the extra copy wastes memory. The
implementation of the BoxArray class uses std::shared_ptr
to an internal container holding the actual Box data. Thus
making a copy of BoxArray is a quite cheap operation. The
conversion of types and coarsening are also cheap because they can
share the internal data with the original BoxArray. In our
implementation, function
refine does create a new deep copy of the original data. Also
note that a BoxArray and its variant with a different type share
the same internal data is an implementation detail. We discuss this
so that the users are aware of the performance and resource cost.
Conceptually we can think of them as completely independent of each
other.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="n">ba</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>  <span class="o">//</span> <span class="n">original</span> <span class="n">BoxArray</span>
<span class="n">BoxArray</span> <span class="n">ba2</span> <span class="o">=</span> <span class="n">ba</span><span class="p">;</span> <span class="o">//</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">that</span> <span class="n">shares</span> <span class="n">the</span> <span class="n">internal</span> <span class="n">data</span> <span class="k">with</span> <span class="n">the</span> <span class="n">original</span>
<span class="n">ba2</span><span class="o">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="o">//</span> <span class="n">Modify</span> <span class="n">the</span> <span class="n">copy</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">original</span> <span class="n">copy</span> <span class="ow">is</span> <span class="n">unmodified</span> <span class="n">even</span> <span class="n">though</span> <span class="n">they</span> <span class="n">share</span> <span class="n">internal</span> <span class="n">data</span><span class="o">.</span>
</pre></div>
</div>
<p>For advanced users, &nbsp;provides functions performing the
intersection of a BoxArray and a Box. These functions are
much faster than a naive implementation of performing intersection of
the Box with each Box in the BoxArray. If one needs
to perform those intersections, functions amrex::intersect, BoxArray::intersects and BoxArray::intersections should be
used.</p>
</div>
<div class="section" id="distributionmapping">
<h1>DistributionMapping<a class="headerlink" href="#distributionmapping" title="Permalink to this headline">¶</a></h1>
<p>DistributionMapping is a class in AMReX_DistributionMapping.H describes which process owns the data
living on the domains specified by the Boxes in a BoxArray. Like BoxArray, there is an element for each Box in DistributionMapping, including the ones owned by other
parallel processes. A way to construct a DistributionMapping
object given a BoxArray is as follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">ba</span><span class="p">};</span>
</pre></div>
</div>
<p>Oftentimes what one needs is simply making a copy.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">another_dm</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that this class is built using std::shared_ptr. Thus
making a copy is relatively cheap in terms of performance and memory
resources. This class has a subscript operator that returns the
process ID at a given index.</p>
<p>By default, DistributionMapping uses an algorithm based on space
filling curve to determine the distribution. One can change the default
via ParmParse parameter DistributionMapping.strategy. KNAPSACK is a common choice that is optimized for load balance.
One can also explicitly construct a distribution.
DistributionMapping class allows the user to have complete control by
passing an array of integers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span><span class="p">;</span>   <span class="o">//</span> <span class="n">empty</span> <span class="nb">object</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">pmap</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">user</span> <span class="n">fills</span> <span class="n">the</span> <span class="n">pmap</span> <span class="n">array</span> <span class="k">with</span> <span class="n">the</span> <span class="n">values</span> <span class="n">specifying</span> <span class="n">owner</span> <span class="n">processes</span>
<span class="n">dm</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">pmap</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Build</span> <span class="n">DistributionMapping</span> <span class="n">given</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">process</span> <span class="n">IDs</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="basefab-farraybox-and-iarraybox">
<h1>BaseFab, FArrayBox and IArrayBox<a class="headerlink" href="#basefab-farraybox-and-iarraybox" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;is a block-structured AMR framework. Although AMR introduces
irregularity to the data and algorithms, there is regularity at the
block/Box level due to rectangular domain, and the data structure
at the Box level is conceptually simple. BaseFab is a
class template for multi-dimensional array-like data structure on a
Box. The template parameter is typically basic types such as
Real, int or char. The dimensionality of the array
is AMREX_SPACEDIM plus one. The additional dimensional is for
the number of components. The data are internally stored in a
contiguous block of memory in Fortran array order (i.e., column-major
order) for <span class="math">\((x,y,z,\mathrm{component})\)</span>, and each component also
occupies a contiguous block of memory because of the ordering. For
example, a BaseFab&lt;Real&gt; with 4 components defined on a
three-dimensional Box(IntVect{-4,8,32},IntVect{32,64,48}) is
like a Fortran array of real(amrex_real),
dimension(-4:32,8:64,32:48,0:3). Note that the convention in part of &nbsp;is the component index is zero based. The code for
constructing such an object is as follows,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">bx</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">48</span><span class="p">});</span>
<span class="nb">int</span> <span class="n">numcomps</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">fab</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span><span class="n">numcomps</span><span class="p">);</span>
</pre></div>
</div>
<p>Most applications do not use BaseFab directly, but utilize
specialized classes derived from BaseFab. The most common types
are FArrayBox in AMReX_FArrayBox.H derived from BaseFab&lt;Real&gt; and IArrayBox in AMReX_IArrayBox.H
derived from BaseFab&lt;int&gt;.</p>
<p>These derived classes also obtain many BaseFab member functions
via inheritance. We now show some common usages of these functions.
To get the Box where a BaseFab or its derived object is
defined, one can call</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To the number of component, one can call</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">nComp</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To get a pointer to the array data, one can call</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">*</span> <span class="n">dataPtr</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>     <span class="o">//</span> <span class="n">Data</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">nth</span> <span class="n">component</span>
                         <span class="o">//</span> <span class="n">T</span> <span class="ow">is</span> <span class="n">template</span> <span class="n">parameter</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span>
<span class="n">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">dataPtr</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">const</span> <span class="n">version</span>
</pre></div>
</div>
<p>The typical usage of the returned pointer is then to pass it to a
Fortran or C function that works on the array data (see
Section&nbsp;[sec:basics:fortran]).
BaseFab has several functions that set the array data to a
constant value (e.g., 0). Two examples are as follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>        <span class="o">//</span> <span class="n">Set</span> <span class="nb">all</span> <span class="n">data</span> <span class="n">to</span> <span class="n">x</span>
<span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">sub</span><span class="o">-</span><span class="n">region</span> <span class="n">specified</span> <span class="n">by</span> <span class="n">bx</span> <span class="n">to</span> <span class="n">value</span> <span class="n">x</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">component</span>
<span class="o">//</span> <span class="n">nstart</span><span class="o">.</span>  <span class="n">ncomp</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">component</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span><span class="o">.</span>
<span class="n">void</span> <span class="n">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nstart</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ncomp</span><span class="p">);</span>
</pre></div>
</div>
<p>One can copy data from one BaseFab to another.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">copy</span> <span class="p">(</span><span class="n">const</span> <span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">srcbox</span><span class="p">,</span> <span class="nb">int</span> <span class="n">srccomp</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">destbox</span><span class="p">,</span> <span class="nb">int</span> <span class="n">destcomp</span><span class="p">,</span> <span class="nb">int</span> <span class="n">numcomp</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the function copies the data from the region specified by srcbox in the source BaseFab src into the region specified by
destbox in the destination BaseFab that invokes the
function call. Note that although srcbox and destbox may
be different, they must be the same size, shape and index type,
otherwise a runtime error occurs. The user also specifies how many
components (int numcomp) are copied starting at component srccomp in src and stored starting at component destcomp. BaseFab has functions returning the minimum or
maximum value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nb">min</span> <span class="p">(</span><span class="nb">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Minimum</span> <span class="n">value</span> <span class="n">of</span> <span class="n">given</span> <span class="n">component</span><span class="o">.</span>
<span class="n">T</span> <span class="nb">min</span> <span class="p">(</span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="nb">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">Minimum</span> <span class="n">value</span> <span class="n">of</span> <span class="n">given</span>
                                             <span class="o">//</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">given</span> <span class="n">subbox</span><span class="o">.</span>
<span class="n">T</span> <span class="nb">max</span> <span class="p">(</span><span class="nb">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Maximum</span> <span class="n">value</span> <span class="n">of</span> <span class="n">given</span> <span class="n">component</span><span class="o">.</span>
<span class="n">T</span> <span class="nb">max</span> <span class="p">(</span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="nb">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">Maximum</span> <span class="n">value</span> <span class="n">of</span> <span class="n">given</span>
                                             <span class="o">//</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">given</span> <span class="n">subbox</span><span class="o">.</span>
</pre></div>
</div>
<p>BaseFab also has many arithmetic functions. Here are some
examples using FArrayBox.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">});</span>
<span class="nb">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">FArrayBox</span> <span class="n">fab1</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="n">fab2</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">fab1</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>    <span class="o">//</span> <span class="n">Fill</span> <span class="n">fab1</span> <span class="k">with</span> <span class="mf">1.0</span>
<span class="n">fab1</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Multiply</span> <span class="n">component</span> <span class="mi">0</span> <span class="n">by</span> <span class="mf">10.0</span>
<span class="n">fab2</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>    <span class="o">//</span> <span class="n">Fill</span> <span class="n">fab2</span> <span class="k">with</span> <span class="mf">2.0</span>
<span class="n">Real</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">fab2</span><span class="o">.</span><span class="n">saxpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fab1</span><span class="p">);</span> <span class="o">//</span> <span class="n">For</span> <span class="n">both</span> <span class="n">components</span><span class="p">,</span> <span class="n">fab2</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">fab1</span> <span class="o">+</span> <span class="n">fab2</span>
</pre></div>
</div>
<p>For more complicated expressions that not supported, one can write
Fortran or C functions for those (Section&nbsp;[sec:basics:fortran]).
Note that BaseFab does provide operators for accessing the
data directly in . For example, the saxpy example above can
be done with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Iterate</span> <span class="n">over</span> <span class="nb">all</span> <span class="n">components</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">icomp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">icomp</span> <span class="o">&lt;</span> <span class="n">fab1</span><span class="o">.</span><span class="n">nComp</span><span class="p">();</span> <span class="o">++</span><span class="n">icomp</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Iterate</span> <span class="n">over</span> <span class="nb">all</span> <span class="n">cells</span> <span class="ow">in</span> <span class="n">Box</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">BoxIterator</span> <span class="n">bit</span><span class="p">(</span><span class="n">fab1</span><span class="o">.</span><span class="n">box</span><span class="p">());</span> <span class="n">bit</span><span class="o">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">bit</span><span class="p">()</span> <span class="n">returns</span> <span class="n">IntVect</span>
        <span class="n">fab2</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">fab1</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">)</span> <span class="o">+</span> <span class="n">fab2</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But this approach is generally not recommended for performance reason.
However, it can be handy for debugging.</p>
<p>BaseFab and its derived classes are containers for data on Box. We recall that Box has types
(Section&nbsp;[sec:basics:box]). The examples in this section so far
use the default cell based type. However, some functions will result
in a runtime error if the types mismatch. For example.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">ccbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>           <span class="o">//</span> <span class="n">cell</span> <span class="n">centered</span> <span class="n">box</span>
<span class="n">Box</span> <span class="n">ndbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>  <span class="o">//</span> <span class="n">nodal</span> <span class="n">box</span>
<span class="n">FArrayBox</span> <span class="n">ccfab</span><span class="p">(</span><span class="n">ccbx</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="n">ndfab</span><span class="p">(</span><span class="n">ndbx</span><span class="p">);</span>
<span class="n">ccfab</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">ndfab</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ccfab</span><span class="p">);</span>   <span class="o">//</span> <span class="n">runtime</span> <span class="n">error</span> <span class="n">due</span> <span class="n">to</span> <span class="nb">type</span> <span class="n">mismatch</span>
</pre></div>
</div>
<p>Because it typically contains a lot of data, BaseFab’s copy
constructor and copy assignment operator are disabled for performance
reason. However, it does provide a move constructor. In addition, it
also provides a constructor for making an alias of an existing
object. Here is an example using FArrayBox.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">FArrayBox</span> <span class="n">orig_fab</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="o">//</span> <span class="mi">4</span><span class="o">-</span><span class="n">component</span> <span class="n">FArrayBox</span>
<span class="o">//</span> <span class="n">Make</span> <span class="n">a</span> <span class="mi">2</span><span class="o">-</span><span class="n">component</span> <span class="n">FArrayBox</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="n">of</span> <span class="n">orig_fab</span>
<span class="o">//</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">component</span> <span class="mf">1.</span>
<span class="n">FArrayBox</span> <span class="n">alias_fab</span><span class="p">(</span><span class="n">orig_fab</span><span class="p">,</span> <span class="n">amrex</span><span class="p">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In the example, the alias FArrayBox has only two components even
though the original one has four components. The alias has a sliced
component view of the original FArrayBox. This is possible
because of the array ordering. It is however not possible to slice in
the real space (i.e., the first AMREX_SPACEDIM dimensions).
Note that no new memory is allocated in constructing the alias and the
alias contains a non-owning pointer. It should be emphasized that the
alias will contain a dangling pointer after the original FArrayBox reaches its end of life.</p>
</div>
<div class="section" id="fabarray-multifab-and-imultifab">
<h1>FabArray, MultiFab and iMultiFab<a class="headerlink" href="#fabarray-multifab-and-imultifab" title="Permalink to this headline">¶</a></h1>
<p>FabArray&lt;FAB&gt; is a class template in AMReX_FabArray.H for
a collection of FABs on the same AMR level associated with a
BoxArray (Section&nbsp;[sec:basics:ba]). The template parameter
FAB is usually BaseFab&lt;T&gt; or its derived classes (e.g.,
FArrayBox). However, it can also be used to hold other data
structures. To construct a FabArray, a BoxArray must be
provided because it is intended to hold <em>grid</em> data defined on
a union of rectangular regions embedded in a uniform index space. For
example, an FabArray object can be used to hold data for one
level of the example grids of Figure&nbsp;4.2.</p>
<p>FabArray is a parallel data structure that the data (i.e.,
FAB) are distributed among parallel processes. On each process,
the FabArray contains only the FAB objects owned by this
process, and the process operates only on its local data. For
operations that require data owned by other processes, remote
communications are involved. Thus, the construction of a FabArray requires a DistributionMapping
(Section&nbsp;[sec:basics:dm]) that specifies which process owns which
Box. For level 2 (<em>red</em>) in
Figure&nbsp;4.2 there are two Boxes. Suppose
there are two parallel processes, and we use a DistributionMapping that assigns one Box to each process.
For FabArray on each process, it is built on a BoxArray with
2 Boxes, but contains only one FAB.</p>
<p>In , there are some specialized classes derived from FabArray. The iMultiFab class in AMReX_iMultiFab.H is
derived from FabArray&lt;IArrayBox&gt;. The most commonly used FabArray kind class is MultiFab in AMReX_MultiFab.H
derived from FabArray&lt;FArrayBox&gt;. In the rest of this section,
we use MultiFab as example. However, these concepts are equally
applicable to other types of FabArrays. There are many ways to
define a MultiFab. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">ba</span> <span class="ow">is</span> <span class="n">BoxArray</span>
<span class="o">//</span> <span class="n">dm</span> <span class="ow">is</span> <span class="n">DistributionMapping</span>
<span class="nb">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="n">mf</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we define a MultiFab with 4 components and 1 ghost cell. A
MultiFab contains a number of FArrayBoxes
(Section&nbsp;[sec:basics:fab]) defined on Boxes grown by the
number of ghost cells (1 in this example). That is the Box in
the FArrayBox is not exactly the same as in the BoxArray.
If the BoxArray has a Box{(8,8,8) (15,15,15)}, the one
used for constructing FArrayBox will be Box{(7,7,7)
(16,16,16)} in this example. For cells in FArrayBox, we
call those in the original Box valid cells and the grown part
ghost cells. Note that FArrayBox itself alone does not have the
concept of ghost cell, whereas ghost cell is a key concept of MultiFab that allows for local operations on ghost cell data
originated from remote processes. We will discuss how to fill ghost
cells with data from valid cells later in this section. MultiFab also has a default constructor. One can define an empty
MultiFab first and then call the define function as
follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="n">mf</span><span class="p">;</span>
<span class="o">//</span> <span class="n">ba</span> <span class="ow">is</span> <span class="n">BoxArray</span>
<span class="o">//</span> <span class="n">dm</span> <span class="ow">is</span> <span class="n">DistributionMapping</span>
<span class="nb">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Given an existing MultiFab, one can also make an alias MultiFab as follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">orig_mf</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">existing</span> <span class="n">MultiFab</span>
<span class="nb">int</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">num_comps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="n">alias_mf</span><span class="p">(</span><span class="n">orig_mf</span><span class="p">,</span> <span class="n">amrex</span><span class="p">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the first integer parameter is the starting component in the
original MultiFab that will become component 0 in the alias MultiFab and the second integer parameter is the number of
components in the alias. It’s a runtime error if the sum of the two
integer parameters is greater than the number of the components in the
original MultiFab. Note that the alias MultiFab has
exactly the same number of ghost cells as the original MultiFab.</p>
<p>We often need to build new MultiFabs that have the same BoxArray and DistributionMapping as a given MultiFab.
Below is an example of how to achieve this.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">mf0</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">already</span> <span class="n">defined</span> <span class="n">MultiFab</span>
<span class="n">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">ba</span> <span class="o">=</span> <span class="n">mf0</span><span class="o">.</span><span class="n">boxArray</span><span class="p">();</span>
<span class="n">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">mf0</span><span class="o">.</span><span class="n">DistributionMap</span><span class="p">();</span>
<span class="nb">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">mf0</span><span class="o">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="nb">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="n">mf0</span><span class="o">.</span><span class="n">nGrow</span><span class="p">();</span>
<span class="n">MultiFab</span> <span class="n">mf1</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="n">ngrow</span><span class="p">);</span>  <span class="o">//</span> <span class="n">new</span> <span class="n">MF</span> <span class="k">with</span> <span class="n">the</span> <span class="n">same</span> <span class="n">ncomp</span> <span class="ow">and</span> <span class="n">ngrow</span>
<span class="n">MultiFab</span> <span class="n">mf2</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>      <span class="o">//</span> <span class="n">new</span> <span class="n">MF</span> <span class="k">with</span> <span class="n">no</span> <span class="n">ghost</span> <span class="n">cells</span>
<span class="o">//</span> <span class="n">new</span> <span class="n">MF</span> <span class="k">with</span> <span class="mi">1</span> <span class="n">component</span> <span class="ow">and</span> <span class="mi">2</span> <span class="n">ghost</span> <span class="n">cells</span>
<span class="n">MultiFab</span> <span class="n">mf3</span><span class="p">(</span><span class="n">mf0</span><span class="o">.</span><span class="n">boxArray</span><span class="p">(),</span> <span class="n">mf0</span><span class="o">.</span><span class="n">DistributionMap</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>As we have repeatedly mentioned in this chapter that Box and
BoxArray have various index types. Thus, MultiFab also
has an index type that is obtained from the BoxArray used for
defining the MultiFab. It should be noted again that index type
is a very important concept in . Let’s consider an example of a
finite-volume code, in which the state is defined as cell averaged
variables and the fluxes are defined as face averaged variables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">ba</span> <span class="ow">is</span> <span class="n">cell</span><span class="o">-</span><span class="n">centered</span> <span class="n">BoxArray</span>
<span class="o">//</span> <span class="n">dm</span> <span class="ow">is</span> <span class="n">DistributionMapping</span>
<span class="nb">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Suppose</span> <span class="n">the</span> <span class="n">system</span> <span class="n">has</span> <span class="mi">3</span> <span class="n">components</span>
<span class="nb">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="o">//</span> <span class="n">no</span> <span class="n">ghost</span> <span class="n">cells</span>
<span class="n">MultiFab</span> <span class="n">state</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="n">xflux</span><span class="p">(</span><span class="n">amrex</span><span class="p">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="n">yflux</span><span class="p">(</span><span class="n">amrex</span><span class="p">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="n">zflux</span><span class="p">(</span><span class="n">amrex</span><span class="p">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Here all MultiFab use the same DistributionMapping, but
their BoxArrays have different index types. The state is cell
based, whereas the fluxes are on the faces. Suppose the cell based
BoxArray contains a Box{(8,8,16), (15,15,31)}. The
state on that Box is conceptually a Fortran Array with the
dimension of (8:15,8:15,16:31,0:2). The fluxes are arrays with
slightly different indices. For example, the <span class="math">\(x\)</span>-direction flux for
that Box has the dimension of (8:16,8:15,16:31,0:2). Note
there is an extra element in <span class="math">\(x\)</span>-direction.</p>
<p>The MultiFab class provides many functions performing common
arithmetic operations on a MultiFab or between MultiFabs
built with the <em>same</em> BoxArray and DistributionMap.
For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">dmin</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>   <span class="o">//</span> <span class="n">Minimum</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">component</span> <span class="mi">3</span> <span class="n">of</span> <span class="n">MultiFab</span> <span class="n">mf</span>
                         <span class="o">//</span> <span class="n">no</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="n">included</span>
<span class="n">Real</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">Maximum</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">component</span> <span class="mi">3</span> <span class="n">of</span> <span class="n">MultiFab</span> <span class="n">mf</span>
                         <span class="o">//</span> <span class="n">including</span> <span class="mi">1</span> <span class="n">ghost</span> <span class="n">cell</span>
<span class="n">mf</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>          <span class="o">//</span> <span class="n">Set</span> <span class="nb">all</span> <span class="n">values</span> <span class="n">to</span> <span class="n">zero</span> <span class="n">including</span> <span class="n">ghost</span> <span class="n">cells</span>

<span class="n">MultiFab</span><span class="p">::</span><span class="n">Add</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Add</span> <span class="n">mfsrc</span> <span class="n">to</span> <span class="n">mfdst</span>
<span class="n">MultiFab</span><span class="p">::</span><span class="n">Copy</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span> <span class="o">//</span> <span class="n">Copy</span> <span class="kn">from</span> <span class="nn">mfsrc</span> <span class="n">to</span> <span class="n">mfdst</span>
<span class="o">//</span> <span class="n">MultiFab</span> <span class="n">mfdst</span><span class="p">:</span> <span class="n">destination</span>
<span class="o">//</span> <span class="n">MultiFab</span> <span class="n">mfsrc</span><span class="p">:</span> <span class="n">source</span>
<span class="o">//</span> <span class="nb">int</span>      <span class="n">sc</span>   <span class="p">:</span> <span class="n">starting</span> <span class="n">component</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">mfsrc</span> <span class="k">for</span> <span class="n">this</span> <span class="n">operation</span>
<span class="o">//</span> <span class="nb">int</span>      <span class="n">dc</span>   <span class="p">:</span> <span class="n">starting</span> <span class="n">component</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">mfdst</span> <span class="k">for</span> <span class="n">this</span> <span class="n">operation</span>
<span class="o">//</span> <span class="nb">int</span>      <span class="n">sc</span>   <span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">components</span> <span class="k">for</span> <span class="n">this</span> <span class="n">operation</span>
<span class="o">//</span> <span class="nb">int</span>      <span class="n">ng</span>   <span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="n">involved</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">operation</span>
<span class="o">//</span>                 <span class="n">mfdst</span> <span class="ow">and</span> <span class="n">mfsrc</span> <span class="n">may</span> <span class="n">have</span> <span class="n">more</span> <span class="n">ghost</span> <span class="n">cells</span>
</pre></div>
</div>
<p>We refer the reader to Src/Base/AMReX_MultiFab.H and Src/Base/AMReX_FabArray.H for more details. It should be noted
again it is a runtime error if the two MultiFabs passed to functions
like MultiFab::Copy are not built with the <em>same</em> BoxArray (including index type) and DistributionMapping.</p>
<p>It is usually the case that the Boxes in the BoxArray used
for building a MultiFab are non-intersecting except that they
can be overlapping due to nodal index type. However, MultiFab
can have ghost cells, and in that case FArrayBoxes are defined
on Boxes larger than the Boxes in the BoxArray.
Parallel communication is then needed to fill the ghost cells with
valid cell data from other FArrayBoxes possibly on other
parallel processes. The function for performing this type of
communication is FillBoundary.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="n">mf</span><span class="p">(</span><span class="o">...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="o">...</span><span class="p">);</span>
<span class="n">Geometry</span> <span class="n">geom</span><span class="p">(</span><span class="o">...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="o">...</span><span class="p">);</span>
<span class="n">mf</span><span class="o">.</span><span class="n">FillBoundary</span><span class="p">();</span>                    <span class="o">//</span> <span class="n">Fill</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">components</span>
                                      <span class="o">//</span> <span class="n">Periodic</span> <span class="n">boundaries</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">filled</span><span class="o">.</span>
<span class="n">mf</span><span class="o">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">periodicity</span><span class="p">());</span>  <span class="o">//</span> <span class="n">Fill</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">components</span>
                                      <span class="o">//</span> <span class="n">Periodic</span> <span class="n">boundaries</span> <span class="n">are</span> <span class="n">filled</span><span class="o">.</span>
<span class="n">mf</span><span class="o">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>        <span class="o">//</span> <span class="n">Fill</span> <span class="mi">3</span> <span class="n">components</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">component</span> <span class="mi">2</span>
<span class="n">mf</span><span class="o">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">periodicity</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that FillBoundary does not modify any valid cells. Also
note that MultiFab itself does not have the concept of
periodic boundary, but Geometry has, and we can provide that
information so that periodic boundaries can be filled as well. You
might have noticed that a ghost cell could overlap with multiple valid
cells from different FArrayBoxes in the case of nodal index
type. In that case, it is unspecified that which valid cell’s value
is used to fill the ghost cell. It ought to be the case the values in
those overlapping valid cells are the same up to roundoff errors.</p>
<p>Another type of parallel communication is copying data from one MultiFab to another MultiFab with a different BoxArray
or the same BoxArray with a different DistributionMapping. The data copy is performed on the regions of
intersection. The most generic interface for this is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="o">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngsrc</span><span class="p">,</span> <span class="n">ngdst</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here mfdst and mfsrc are destination and source MultiFabs, respectively. Parameters compsrc, compdst, and ncomp are integers specifying the range of components. The copy is
performed on ncomp components starting from component compsrc of
mfsrc and component compdst of mfdst. Parameters ngsrc and ngdst specify the number of ghost cells involved for
the source and destination, respectively. Parameter period is
optional, and by default no periodic copy is performed. Like FillBoundary, one can use Geometry::periodicity() to provide
the periodicity information. The last parameter is also optional and
is set to FabArrayBase::COPY by default. One could also use
FabArrayBase::ADD. This determines whether the function copies
or adds data from the source to the destination. Same as FillBoundary, if a destination cell has multiple cells as source,
it is unspecified that which source cell is used. This function has
two variants, in which the periodicity and operation type are also
optional.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="o">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>  <span class="o">//</span> <span class="n">mfdst</span> <span class="ow">and</span> <span class="n">mfsrc</span> <span class="n">must</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span>
                                        <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">components</span>
<span class="n">mfdst</span><span class="o">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the number of ghost cells involved is zero, and the copy is
performed on all components if unspecified (assuming the two MultiFabs have the same number of components). Similar to FillBoundary, a destination cell may have multiple sources and
which source is used is unspecified.</p>
</div>
<div class="section" id="mfiter-and-tiling">
<h1>MFIter and Tiling<a class="headerlink" href="#mfiter-and-tiling" title="Permalink to this headline">¶</a></h1>
<p>In this section, we will first show how MFIter works without
tiling. Then we will introduce the concept of logical tiling.
Finally we will show how logical tiling can be launched via MFIter.</p>
<div class="section" id="mfiter-without-tiling">
<h2>MFIter without Tiling<a class="headerlink" href="#mfiter-without-tiling" title="Permalink to this headline">¶</a></h2>
<p>In Section&nbsp;[sec:basics:multifab], we have shown some of the
arithmetic functionalities of MultiFab, such as adding two MultiFabs together. In this section, we will show how you can
operate on the MultiFab data with your own functions. provides an iterator, MFIter for looping over the FArrayBoxes in MultiFabs. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">grids</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">valid</span> <span class="n">Box</span> <span class="n">of</span> <span class="n">the</span> <span class="n">current</span> <span class="n">FArrayBox</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">By</span> <span class="s2">&quot;valid&quot;</span><span class="p">,</span> <span class="n">we</span> <span class="n">mean</span> <span class="n">the</span> <span class="n">original</span> <span class="n">ungrown</span> <span class="n">Box</span> <span class="ow">in</span> <span class="n">BoxArray</span><span class="o">.</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">A</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">FArrayBox</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">loop</span> <span class="n">iteration</span><span class="o">.</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">floating</span> <span class="n">point</span> <span class="n">data</span> <span class="n">of</span> <span class="n">this</span> <span class="n">FArrayBox</span><span class="o">.</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">Box</span> <span class="n">on</span> <span class="n">which</span> <span class="n">the</span> <span class="n">FArrayBox</span> <span class="ow">is</span> <span class="n">defined</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Note</span> <span class="n">that</span> <span class="s2">&quot;abox&quot;</span> <span class="n">includes</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="p">(</span><span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="nb">any</span><span class="p">),</span>
    <span class="o">//</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">thus</span> <span class="n">larger</span> <span class="n">than</span> <span class="ow">or</span> <span class="n">equal</span> <span class="n">to</span> <span class="s2">&quot;box&quot;</span><span class="o">.</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">We</span> <span class="n">can</span> <span class="n">now</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">information</span> <span class="n">to</span> <span class="n">a</span> <span class="n">function</span> <span class="n">that</span> <span class="n">does</span>
    <span class="o">//</span> <span class="n">work</span> <span class="n">on</span> <span class="n">the</span> <span class="n">region</span> <span class="p">(</span><span class="n">specified</span> <span class="n">by</span> <span class="n">box</span><span class="p">)</span> <span class="n">of</span> <span class="n">the</span> <span class="n">data</span> <span class="n">pointed</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">by</span> <span class="n">Real</span><span class="o">*</span> <span class="n">a</span><span class="o">.</span>  <span class="n">The</span> <span class="n">data</span> <span class="n">should</span> <span class="n">be</span> <span class="n">viewed</span> <span class="k">as</span> <span class="n">a</span> <span class="n">multidimensional</span>
    <span class="o">//</span> <span class="k">with</span> <span class="n">bounds</span> <span class="n">specified</span> <span class="n">by</span> <span class="n">abox</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Function</span> <span class="n">f1</span> <span class="n">has</span> <span class="n">the</span> <span class="n">signature</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">Real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">);</span>
    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">abox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">abox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here function f1 is usually a Fortran subroutine with ISO C
binding interface like below,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f1</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">alo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ahi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">a</span><span class="p">(</span><span class="n">alo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">alo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">alo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
  <span class="n">integer</span> <span class="p">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>
  <span class="n">do</span>     <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">do</span>   <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="n">do</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="o">...</span>
      <span class="n">end</span> <span class="n">do</span>
    <span class="n">end</span> <span class="n">do</span>
  <span class="n">end</span> <span class="n">do</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f1</span>
</pre></div>
</div>
<p>Here amrex_fort_module is a Fortran module in &nbsp;and amrex_real is a Fortran kind parameter that matches amrex::Real in . In this example, we assume the spatial
dimension is 3. In 2D, the function interface is different. In
Section&nbsp;[sec:basics:fortran], we will present a dimension agnostic
approach using macros provided by .</p>
<p>MFIter only loops over grids owned by this process. For
example, suppose there are 5 Boxes in total and processes 0 and
1 own 2 and 3 Boxes, respectively. That is the MultiFab
on process 0 has 2 FArrayBoxes, whereas there are 3 FArrayBoxes on process 1. Thus the numbers of iterations of MFIter are 2 and 3 on processes 0 and 1, respectively.</p>
<p>In the example above, MultiFab is assumed to have a single
component. If it has multiple component, we can call int nc =
mf.nComp() to get the number of components and pass it to the
kernel function.</p>
<p>There is only one MultiFab in the example above. Below is an
example of working with multiple MultiFabs. Note that these two
MultiFabs are not necessarily built on the same BoxArray.
But they must have the same DistributionMapping, and their BoxArrays are typically related (e.g., they are different due to
index types).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">U</span> <span class="ow">and</span> <span class="n">F</span> <span class="n">are</span> <span class="n">MultiFabs</span>
<span class="nb">int</span> <span class="n">ncU</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">nComp</span><span class="p">();</span>   <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">components</span>
<span class="nb">int</span> <span class="n">ncF</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">grids</span>
<span class="p">{</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="n">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">ufab</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span>       <span class="n">ffab</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="n">Real</span><span class="o">*</span> <span class="n">up</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">ubox</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">fbox</span> <span class="o">=</span> <span class="n">ffab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Function</span> <span class="n">f2</span> <span class="n">has</span> <span class="n">the</span> <span class="n">signature</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span>
    <span class="o">//</span>         <span class="n">const</span> <span class="n">Real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span>
    <span class="o">//</span>               <span class="n">Real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">will</span> <span class="n">compute</span> <span class="n">f</span> <span class="n">using</span> <span class="n">u</span> <span class="k">as</span> <span class="n">inputs</span><span class="o">.</span>
    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span>
       <span class="n">up</span><span class="p">,</span> <span class="n">ubox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">ubox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncU</span><span class="p">,</span>
       <span class="n">fp</span><span class="p">,</span> <span class="n">fbox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">fbox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncF</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here again function f2 is usually a Fortran subroutine with ISO
C binding interface like below,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f2</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">,</span><span class="n">flo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">fhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nf</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="ow">in</span>   <span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">)</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">f</span><span class="p">(</span><span class="n">flo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">flo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">flo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nf</span><span class="p">)</span>
  <span class="n">integer</span> <span class="p">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>
  <span class="n">do</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nf</span>
    <span class="n">do</span>     <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="n">do</span>   <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">do</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="o">...</span> <span class="n">u</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">...</span>
        <span class="n">end</span> <span class="n">do</span>
      <span class="n">end</span> <span class="n">do</span>
    <span class="n">end</span> <span class="n">do</span>
  <span class="n">end</span> <span class="n">do</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f2</span>
</pre></div>
</div>
</div>
<div class="section" id="mfiter-with-tiling">
<h2>MFIter with Tiling<a class="headerlink" href="#mfiter-with-tiling" title="Permalink to this headline">¶</a></h2>
<p>Tiling, also known as cache blocking, is a well known loop
transformation technique for improving data locality. This is often
done by transforming the loops into tiling loops that iterate over
tiles and element loops that iterate over the data elements within a
tile. For example, the original loops might look like</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">do</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span>
  <span class="n">do</span> <span class="n">j</span> <span class="o">=</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span>
    <span class="n">do</span> <span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
      <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0</span><span class="n">d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
    <span class="n">end</span> <span class="n">do</span>
  <span class="n">end</span> <span class="n">do</span>
<span class="n">end</span> <span class="n">do</span>
</pre></div>
</div>
<p>And the manually tiled loops might look like</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">jblocksize</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">kblocksize</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">jblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmax</span><span class="o">-</span><span class="n">jmin</span><span class="o">+</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">jblocksize</span>
<span class="n">kblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">kmax</span><span class="o">-</span><span class="n">kmin</span><span class="o">+</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">kblocksize</span>
<span class="n">do</span> <span class="n">kb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kblocks</span><span class="o">-</span><span class="mi">1</span>
  <span class="n">do</span> <span class="n">jb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jblocks</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">do</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kb</span><span class="o">*</span><span class="n">kblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">kb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">kmax</span><span class="p">)</span>
      <span class="n">do</span> <span class="n">j</span> <span class="o">=</span> <span class="n">jb</span><span class="o">*</span><span class="n">jblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">jb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">jmax</span><span class="p">)</span>
        <span class="n">do</span> <span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
          <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">&amp;</span>
                    <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0</span><span class="n">d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="n">end</span> <span class="n">do</span>
      <span class="n">end</span> <span class="n">do</span>
    <span class="n">end</span> <span class="n">do</span>
  <span class="n">end</span> <span class="n">do</span>
<span class="n">end</span> <span class="n">do</span>
</pre></div>
</div>
<p>As we can see, to manually tile individual loops is very
labor-intensive and error-prone for large applications. &nbsp;has
incorporated the tiling construct into MFIter so that the
application codes can get the benefit of tiling easily. An MFIter loop with tiling is almost the same as the non-tiling
version. The first example in
Section&nbsp;[sec:basics:mfiter:notiling] requires only two minor
changes: (1) passing true when defining MFIter to indicate
tiling; (2) calling tilebox instead of validbox to obtain
the work region for the loop iteration.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>               <span class="o">*</span> <span class="n">true</span> <span class="o">*</span>  <span class="n">turns</span> <span class="n">on</span> <span class="n">tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">true</span><span class="p">);</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">tiles</span>
<span class="p">{</span>
    <span class="o">//</span>                   <span class="n">tilebox</span><span class="p">()</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">validbox</span><span class="p">()</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>

    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">abox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">abox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second example in Section&nbsp;[sec:basics:mfiter:notiling] also
requires only two minor changes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>              <span class="o">*</span> <span class="n">true</span> <span class="o">*</span>  <span class="n">turns</span> <span class="n">on</span> <span class="n">tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">true</span><span class="p">);</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">tiles</span>
<span class="p">{</span>
    <span class="o">//</span>                   <span class="n">tilebox</span><span class="p">()</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">validbox</span><span class="p">()</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="n">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">ufab</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span>       <span class="n">ffab</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="n">Real</span><span class="o">*</span> <span class="n">up</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">ubox</span> <span class="o">=</span> <span class="n">ufab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">fbox</span> <span class="o">=</span> <span class="n">ffab</span><span class="o">.</span><span class="n">box</span><span class="p">();</span>

    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span>
       <span class="n">up</span><span class="p">,</span> <span class="n">ubox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">ubox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncU</span><span class="p">,</span>
       <span class="n">fp</span><span class="p">,</span> <span class="n">fbox</span><span class="o">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">fbox</span><span class="o">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncF</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernels functions like f1 and f2 in the two examples
here usually require very little changes.</p>
<div class="figure" id="id4">
<a class="reference internal image-reference" href="../Basics/cc_validbox.png"><img alt="../Basics/cc_validbox.png" src="../Basics/cc_validbox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.4: Example of cell-centered tile boxes.
Each grid is <em>logically</em> broken into 4 tiles, and each
tile has <span class="math">\(4^2\)</span> cells. There are 8 tiles in total.</span></p>
</div>
<div class="figure" id="id5">
<a class="reference internal image-reference" href="../Basics/cc_tilebox.png"><img alt="../Basics/cc_tilebox.png" src="../Basics/cc_tilebox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.5: Example of cell-centered tile boxes.
Each grid is <em>logically</em> broken into 4 tiles, and each
tile has <span class="math">\(4^2\)</span> cells. There are 8 tiles in total.</span></p>
</div>
<p>Figures&nbsp;4.4 &amp; 4.5
show an example of the difference between validbox and tilebox. In this example, there are two grids of cell-centered
index type. Function validbox always returns a Box for the
valid region of an FArrayBox no matter whether or not tiling is
enabled, whereas function tilebox returns a Box for a
tile. (Note that when tiling is disabled, tilebox returns the
same Box as validbox.) The number of loop iteration is 2
in the non-tiling version, whereas in the tiling version the kernel
function is called 8 times.</p>
<p>The tile size can be explicitly set when defining MFIter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">No</span> <span class="n">tiling</span> <span class="ow">in</span> <span class="n">x</span><span class="o">-</span><span class="n">direction</span><span class="o">.</span> <span class="n">Tile</span> <span class="n">size</span> <span class="ow">is</span> <span class="mi">16</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">and</span> <span class="mi">32</span> <span class="k">for</span> <span class="n">z</span><span class="o">.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">IntVect</span><span class="p">(</span><span class="mi">1024000</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">));</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>An IntVect is used to specify the tile size for every dimension.
A tile size larger than the grid size simply means tiling is disable
in that direction. &nbsp;has a default tile size IntVect{1024000,8,8} in 3D and no tiling in 2D. This is used
when tile size is not explicitly set but the tiling flag is on. One
can change the default size using ParmParse parameter fabarray.mfiter_tile_size.</p>
<div class="figure" id="id6">
<a class="reference internal image-reference" href="../Basics/ec_validbox.png"><img alt="../Basics/ec_validbox.png" src="../Basics/ec_validbox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.6: Example of face tile boxes.
Each grid is <em>logically</em> broken into 4 tiles as indicated
by the symbols. There are 8 tiles in total. Some tiles have
5x4 points, whereas others have 4x4 points.
Points from different Boxes may overlap, but points from
different tiles of the same Box do not.</span></p>
</div>
<div class="figure" id="id7">
<a class="reference internal image-reference" href="../Basics/ec_tilebox.png"><img alt="../Basics/ec_tilebox.png" src="../Basics/ec_tilebox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.7: Example of face tile boxes.
Each grid is <em>logically</em> broken into 4 tiles as indicated
by the symbols. There are 8 tiles in total. Some tiles have
5x4 points, whereas others have 4x4 points.
Points from different Boxes may overlap, but points from
different tiles of the same Box do not.</span></p>
</div>
<p>Usually MFIter is used for accessing multiple MultiFabs
like the second example, in which two MultiFabs, U and
F, use MFIter via operator []. These different MultiFabs may have different BoxArrays. For example, U
might be cell-centered, whereas F might be nodal in
<span class="math">\(x\)</span>-direction and cell in other directions. The MFIter::validbox and tilebox functions return Boxes of
the same type as the MultiFab used in defining the MFIter
(F in this example). Figures&nbsp;4.6 &amp; 4.7 show an example of non-cell-centered valid
and tile boxes. Besides validbox and tilebox, MFIter has a number of functions returning various Boxes.
Examples include,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="n">fabbox</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>       <span class="o">//</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">Box</span> <span class="n">of</span> <span class="n">the</span> <span class="n">FArrayBox</span>

<span class="o">//</span> <span class="n">Return</span> <span class="n">grown</span> <span class="n">tile</span> <span class="n">box</span><span class="o">.</span>  <span class="n">By</span> <span class="n">default</span> <span class="n">it</span> <span class="n">grows</span> <span class="n">by</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span>
<span class="o">//</span> <span class="n">ghost</span> <span class="n">cells</span> <span class="n">of</span> <span class="n">the</span> <span class="n">MultiFab</span> <span class="n">used</span> <span class="k">for</span> <span class="n">defining</span> <span class="n">the</span> <span class="n">MFIter</span><span class="o">.</span>
<span class="n">Box</span> <span class="n">growntilebox</span><span class="p">(</span><span class="nb">int</span> <span class="n">ng</span><span class="o">=-</span><span class="mi">1000000</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Return</span> <span class="n">tilebox</span> <span class="k">with</span> <span class="n">provided</span> <span class="n">nodal</span> <span class="n">flag</span> <span class="k">as</span> <span class="k">if</span> <span class="n">the</span> <span class="n">MFIter</span>
<span class="o">//</span> <span class="ow">is</span> <span class="n">constructed</span> <span class="k">with</span> <span class="n">MultiFab</span> <span class="n">of</span> <span class="n">such</span> <span class="n">flag</span><span class="o">.</span>
<span class="n">Box</span> <span class="n">tilebox</span><span class="p">(</span><span class="n">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">nodal_flag</span><span class="p">);</span>
</pre></div>
</div>
<p>It should be noted that function growntilebox does not grow the
tile Box like a normal Box. Growing a Box normally
means the Box is extended in every face of every dimension.
However, function growntilebox only extends the tile Box
in such a way that tiles from the same grid do not overlap. This is
the basic design principle of these various tiling functions. Tiling
is a way of domain decomposition for work sharing. Overlapping tiles
is undesirable because works would be wasted and for multi-threaded
codes race conditions could occur.
Figures&nbsp;4.8 &amp; 4.9 show examples of growntilebox.</p>
<div class="figure" id="id8">
<a class="reference internal image-reference" href="../Basics/cc_growbox.png"><img alt="../Basics/cc_growbox.png" src="../Basics/cc_growbox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.8: Example of face type grown
tile boxes. As indicated by symbols, there are 8 tiles and
four in each grid in this example. Tiles from the same grid do
not overlap even though they have face index type.</span></p>
</div>
<div class="figure" id="id9">
<a class="reference internal image-reference" href="../Basics/ec_growbox.png"><img alt="../Basics/ec_growbox.png" src="../Basics/ec_growbox.png" style="width: 30.0%;" /></a>
<p class="caption"><span class="caption-text">Figure 4.9: Example of face type grown
tile boxes. As indicated by symbols, there are 8 tiles and
four in each grid in this example. Tiles from the same grid do
not overlap even though they have face index type.</span></p>
</div>
<p>These functions in MFIter return Box by value. There are
two ways of using these functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">validbox</span><span class="p">();</span>  <span class="o">//</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">to</span> <span class="n">temporary</span> <span class="nb">object</span> <span class="ow">is</span> <span class="n">legal</span>

<span class="o">//</span> <span class="n">Make</span> <span class="n">a</span> <span class="n">copy</span> <span class="k">if</span> <span class="n">Box</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">modified</span> <span class="n">later</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Compilers</span> <span class="n">can</span> <span class="n">optimize</span> <span class="n">away</span> <span class="n">the</span> <span class="n">temporary</span> <span class="nb">object</span><span class="o">.</span>
<span class="n">Box</span> <span class="n">bx2</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">validbox</span><span class="p">();</span>
<span class="n">bx2</span><span class="o">.</span><span class="n">surroundingNodes</span><span class="p">();</span>
</pre></div>
</div>
<p>But Box&amp; bx = mfi.validbox() is not legal and will not compile.</p>
</div>
</div>
<div class="section" id="calling-fortran-or-c">
<h1>Calling Fortran or C<a class="headerlink" href="#calling-fortran-or-c" title="Permalink to this headline">¶</a></h1>
<p>In Section&nbsp;[sec:basics:mfiter], we have shown that a typical
pattern for working with MultiFabs is use MFIter to
iterate over the data. In each iteration, a kernel function is called
to work on the data and the work region is specified by a Box.
When tiling is used, the work region is a tile. The tiling is logical
in the sense that there is no data layout transformation. The kernel
function still gets the whole arrays in FArrayBoxes, even though
it is supposed to work on a tile region of the arrays. To , these
kernel functions are C functions, whose function signatures are
typically declared in a header file named _f.H or *_F.H. We recommend the users to follow this convention.
Examples of these function declarations are as follows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;AMReX_BLFort.H&gt;</span>
<span class="c1">#ifdef __cplusplus</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span>
<span class="p">{</span>
<span class="c1">#endif</span>
    <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span>
            <span class="n">const</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span>
            <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span><span class="o">*</span><span class="p">);</span>
<span class="c1">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>One can write the functions in C and should include the header
containing the function declarations in the C source code to ensure
type safety. However, we typically write these kernel functions in
Fortran because of the native multi-dimensional array support by
Fortran. As we have seen in Section&nbsp;[sec:basics:mfiter], these
Fortran functions take C pointers and view them as multi-dimensional
arrays of the shape specified by the additional integer arguments.
Note that Fortran takes arguments by reference unless the value
keyword is used. So an integer argument on the Fortran side matches
an integer pointer on the &nbsp;side. Thanks to Fortran 2003,
function name mangling is easily achieved by declaring the Fortran
function as bind(c).</p>
<p>&nbsp;provides many macros for passing an FArrayBox’s data
into Fortran/C. For example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">true</span><span class="p">);</span> <span class="n">mfi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="o">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">f</span><span class="p">(</span><span class="n">BL_TO_FORTRAN_BOX</span><span class="p">(</span><span class="n">box</span><span class="p">),</span>
      <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here BL_TO_FORTRAN_BOX takes a Box and provides two
int*s specifying the lower and upper bounds of the Box.
BL_TO_FORTRAN_ANYD takes an FArrayBox returned by mf[mfi] and the preprocessor turns it into Real*, int*, int*,
where Real* is the data pointer that matches real array argument
in Fortran, the first int* (which matches an integer argument in
Fortran) specifies the lower bounds, and the second int* the
upper bounds of the spatial dimensions of the array. Similar to what
we have seen in Section&nbsp;[sec:basics:mfiter], a matching Fortran
function is shown below,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f</span>
</pre></div>
</div>
<p>Here, the size of the integer arrays is 3, the maximal number of
spatial dimensions. If the actual spatial dimension is less than 3,
the values in the degenerate dimensions are set to zero. So the
Fortran function interface does not have to change according to the
spatial dimensionality, and the bound of the third dimension of the
data array simply becomes 0:0. With the data passed by BL_TO_FORTRAN_BOX and BL_FORTRAN_ANYD, this version of
Fortran function interface works for any spatial dimensions. If one
wants to write a special version just for 2D and would like to use 2D
arrays, one can use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f2d</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f2d</span>
</pre></div>
</div>
<p>Note that this does not require any changes in &nbsp;part, because
when &nbsp;passes an integer pointer pointing to an array of three
integers Fortran can treat it as a 2-element integer array.</p>
<p>Another commonly used macro is BL_TO_FORTRAN. This macro
takes an FArrayBox and provides a real pointer for the floating
point data array and a number of integer scalars for the bounds.
However, the number of the integers depends on the dimensionality.
More specifically, there are 6 and 4 integers for 2D and 3D,
respectively. The first half of the integers are the lower bounds for
each spatial dimension and the second half the upper bounds. For
example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">)</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f2d</span>

<span class="n">subroutine</span> <span class="n">f3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">,</span><span class="n">ulo3</span><span class="p">:</span><span class="n">uhi3</span><span class="p">)</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f3d</span>
</pre></div>
</div>
<p>Here for simplicity we have omitted passing the tile Box.</p>
<p>Usually MultiFabs have multiple components. Thus we often also
need to pass the number of component into Fortran functions. We can
obtain the number by calling the MultiFab::nComp() function, and
pass it to Fortran as we have seen in Section&nbsp;[sec:basics:mfiter].
We can also use the BL_TO_FORTRAN_FAB macro that is similar
to BL_TO_FORTRAN_ANYD except that it provides an additional
int* for the number of components. The Fortran function
matching BL_TO_FORTRAN_FAB(fab) is then like below,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">,</span><span class="n">nu</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span>
  <span class="n">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">)</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="ghost-cells">
<h1>Ghost Cells<a class="headerlink" href="#ghost-cells" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;uses MultiFab as the data container for floating point
data on multiple Boxes on a single AMR level. Each rectangular
Box has its own boundaries. A MultiFab can have ghost cells for
storing data outside its grid Box boundaries. This allows us to
perform stencil type of operations on regular arrays. There are three
basic types of boundaries: (1) interior boundary; (2) coarse/fine
boundary; and (3) physical boundary. Periodic boundary is not
considered a basic type in the discussion here because after periodic
transformation it becomes either interior boundary or coarse/fine
boundary.</p>
<p>Interior boundary is the border among the grid Boxes themselves.
For example, in Figure&nbsp;4.2, the two blue grid
Boxes on level 1 share an interior boundary that is 10 cells
long. For a MultiFab with ghost cells on level 1, we can use
the MultiFab::FillBoundary function introduced in
Section&nbsp;[sec:basics:multifab] to fill ghost cells at the interior
boundary with valid cell data from other Boxes.</p>
<p>Coarse/fine boundary is the border between two AMR levels. FillBoundary does not fill these ghost cells. These ghost cells on
the fine level need to be interpolated from the coarse level data.
This is a subject that will be discussed in
Section&nbsp;[sec:amrcore:fillpatch].</p>
<p>The third type of boundary is the physical boundary at the physical
domain. Note that both coarse and fine AMR levels could have grids
touching the physical boundary. It is up to the application codes to
properly fill the ghost cells at the physical boundary. However,
&nbsp;does provide support for some common operations.
See Chapter [Chap:Boundary] for a discussion on domain
boundary conditions in general, including how to implement
physical (non-periodic) boundary conditions.</p>
</div>
<div class="section" id="i-o">
<h1>I/O<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h1>
<p>In this section, we will discuss parallel I/O capabilities for mesh
data in . Section&nbsp;[sec:Particles:IO] will discuss I/O for
particle data.</p>
<div class="section" id="plotfile">
<h2>Plotfile<a class="headerlink" href="#plotfile" title="Permalink to this headline">¶</a></h2>
<p>&nbsp;has its native plotfile format. Many visualization tools are
available for &nbsp;plotfiles
(Chapter&nbsp;[Chap:Visualization]). &nbsp;provides the following
two functions for writing a generic &nbsp;plotfile. Many application codes may have their own plotfile routines that store
additional information such as compiler options, git hashes of the
source codes and ParmParse runtime parameters.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">WriteSingleLevelPlotfile</span> <span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                               <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                               <span class="nb">int</span> <span class="n">level_step</span><span class="p">);</span>

<span class="n">void</span> <span class="n">WriteMultiLevelPlotfile</span> <span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                              <span class="nb">int</span> <span class="n">nlevels</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">const</span> <span class="n">MultiFab</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                              <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">level_steps</span><span class="p">,</span>
                              <span class="n">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">IntVect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ref_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>WriteSingleLevelPlotfile is for single level runs and WriteMultiLevelPlotfile is for multiple levels. The name of the
plotfile is specified by the plotfilename argument. This is the
top level directory name for the plotfile. In &nbsp;convention, the
plotfile name consist of letters followed by numbers (e.g., plt00258). amrex::Concatenate is a useful helper function for
making such strings.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">istep</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s2">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="o">//</span> <span class="n">plt00258</span>

<span class="o">//</span> <span class="n">By</span> <span class="n">default</span> <span class="n">there</span> <span class="n">are</span> <span class="mi">5</span> <span class="n">digits</span><span class="p">,</span> <span class="n">but</span> <span class="n">we</span> <span class="n">can</span> <span class="n">change</span> <span class="n">it</span> <span class="n">to</span> <span class="n">say</span> <span class="mf">4.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname2</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s2">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="o">//</span> <span class="n">plt0258</span>

<span class="n">istep</span> <span class="o">=</span><span class="mi">1234567</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Having</span> <span class="n">more</span> <span class="n">than</span> <span class="mi">5</span> <span class="n">digits</span> <span class="ow">is</span> <span class="n">OK</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname3</span> <span class="o">=</span> <span class="n">amrex</span><span class="p">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s2">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="o">//</span> <span class="n">plt12344567</span>
</pre></div>
</div>
<p>Argument mf (MultiFab for single level and Vector&lt;const MultiFab*&gt; for multi-level) is the data to be written
to the disk. Note that many visualization tools expect this to be
cell-centered data. So for nodal data, we need to convert them to
cell-centered data through some kind of averaging. Also note that if
you have data at each AMR level in several MultiFabs, you need
to build a new MultiFab at each level to hold all the data on
that level. This involves local data copy in memory and is not
expected to significantly increase the total wall time for writing
plotfiles. For the multi-level version, the function expects Vector&lt;const MultiFab*&gt;, whereas the multi-level data are often
stored as Vector&lt;std::unique_ptr&lt;MultiFab&gt;&gt;. &nbsp;has a
helper function for this and one can use it as follows,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">WriteMultiLevelPlotfile</span><span class="p">(</span><span class="o">......</span><span class="p">,</span> <span class="n">amrex</span><span class="p">::</span><span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">mf</span><span class="p">),</span> <span class="o">......</span><span class="p">);</span>
</pre></div>
</div>
<p>Argument varnames has the names for each component of the MultiFab data. The size of the Array should be equal to the
number of components. Argument geom is for passing Geometry objects that contain the physical domain
information. Argument time is for the time associated with the
data. Argument level_step is for the current time step
associated with the data. For multi-level plotfiles, argument nlevels is the total number of levels, and we also need to provide
the refinement ratio via an Array of size nlevels-1.</p>
<p>We note that &nbsp;does not overwrite old plotfiles if the new
plotfile has the same name. The old plotfiles will be renamed to
new directories named like plt00350.old.46576787980.</p>
</div>
<div class="section" id="checkpoint-file">
<h2>Checkpoint File<a class="headerlink" href="#checkpoint-file" title="Permalink to this headline">¶</a></h2>
<p>Checkpoint files are used for restarting simulations from where the
checkpoints are written. Each application code has its own set of
data needed for restart. &nbsp;provides I/O functions for basic
data structures like MultiFab and BoxArray. These
functions can be used to build codes for reading and writing
checkpoint files. Since each application code has its own
requirement, there is no standard &nbsp;checkpoint format.</p>
<p>Typically a checkpoint file is a directory containing some text files
and sub-directories (e.g., Level_0 and Level_1)
containing various data. It is a good idea that we fist make these
directories ready for subsequently writing to the disk. For example,
to build directories chk00016, chk00016/Level_0, and chk00016/Level_1, we do</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chkname</span> <span class="p">{</span><span class="s2">&quot;chk00016&quot;</span><span class="p">};</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">subDirPrefix</span> <span class="p">{</span><span class="s2">&quot;Level_&quot;</span><span class="p">};</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">nSubDirs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">const</span> <span class="nb">bool</span> <span class="n">callBarrier</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span> <span class="o">//</span> <span class="n">Parallel</span> <span class="n">barrier</span> <span class="n">after</span> <span class="n">directories</span> <span class="n">are</span> <span class="n">built</span><span class="o">.</span>
<span class="n">PreBuildDirectorHierarchy</span><span class="p">(</span><span class="n">chkname</span><span class="p">,</span> <span class="n">subDirPrefix</span><span class="p">,</span> <span class="n">nSubDirs</span><span class="p">,</span> <span class="n">callBarrier</span><span class="p">);</span>
</pre></div>
</div>
<p>A checkpoint file of &nbsp;application codes often has a clear text
Header file that only the I/O process writes to it using std::ofstream. The Header file contains information such as
the time, the physical domain size, grids, etc. that are necessary for
restarting the simulation. To guarantee that precision is not lost
for storing floating point number like time in clear text file, the
file stream’s precision needs to be set properly. And a stream buffer
can also be used. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">IOProcessor</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chkname</span> <span class="o">=</span> <span class="s2">&quot;chk00016&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">HeaderFileName</span><span class="p">(</span><span class="n">chkname</span><span class="o">+</span><span class="s2">&quot;/Header&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="p">::</span><span class="n">ofstream</span> <span class="n">HeaderFile</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="o">.</span><span class="n">c_str</span><span class="p">(),</span>
         <span class="n">std</span><span class="p">::</span><span class="n">ofstream</span><span class="p">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">std</span><span class="p">::</span><span class="n">ofstream</span><span class="p">::</span><span class="n">trunc</span> <span class="o">|</span> <span class="n">std</span><span class="p">::</span><span class="n">ofstream</span><span class="p">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="n">HeaderFile</span><span class="o">.</span><span class="n">precision</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span><span class="p">::</span><span class="n">max_digits10</span><span class="p">);</span>
    <span class="n">VisMF</span><span class="p">::</span><span class="n">IO_Buffer</span> <span class="n">io_buffer</span><span class="p">(</span><span class="n">VisMF</span><span class="p">::</span><span class="n">IO_Buffer_Size</span><span class="p">);</span>
    <span class="n">HeaderFile</span><span class="o">.</span><span class="n">rdbuf</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pubsetbuf</span><span class="p">(</span><span class="n">io_buffer</span><span class="o">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">io_buffer</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Checkpoint version 1.0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">time</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">domain_box</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="o">//</span> <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="o">......</span><span class="p">;</span>
    <span class="n">box_array</span><span class="o">.</span><span class="n">writeOn</span><span class="p">(</span><span class="n">HeaderFile</span><span class="p">);</span> <span class="o">//</span> <span class="n">write</span> <span class="n">BoxArray</span>
    <span class="o">//</span> <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="o">......</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For reading the Header file, &nbsp;can have the I/O process
read the file from the disk and broadcast it to others as Vector&lt;char&gt;. Then all processes can read the information with std::istringstream. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">HeaderFileName</span> <span class="p">{</span><span class="s2">&quot;chk00016/Header&quot;</span><span class="p">};</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span> <span class="n">fileChar</span><span class="p">;</span>
<span class="n">ParallelDescriptor</span><span class="p">::</span><span class="n">ReadAndBcastFile</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="p">,</span> <span class="n">fileChar</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">istringstream</span> <span class="ow">is</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">{</span><span class="n">fileChar</span><span class="o">.</span><span class="n">data</span><span class="p">()},</span> <span class="n">std</span><span class="p">::</span><span class="n">istringstream</span><span class="p">::</span><span class="ow">in</span><span class="p">);</span>
<span class="o">//</span> <span class="ow">is</span> <span class="o">&gt;&gt;</span> <span class="o">....</span><span class="p">;</span>
<span class="n">BoxArray</span> <span class="n">ba</span><span class="p">;</span>
<span class="n">ba</span><span class="o">.</span><span class="n">readFrom</span><span class="p">(</span><span class="ow">is</span><span class="p">);</span>
<span class="o">//</span> <span class="ow">is</span> <span class="o">&gt;&gt;</span> <span class="o">....</span><span class="p">;</span>
</pre></div>
</div>
<p>amrex::VisMF is a class that can be used to perform MultiFab I/O in parallel. How many processes are allowed to
perform I/O simultaneously can be set via</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">VisMF</span><span class="p">::</span><span class="n">SetNOutFiles</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>  <span class="o">//</span> <span class="n">up</span> <span class="n">to</span> <span class="mi">64</span> <span class="n">processes</span><span class="p">,</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">also</span> <span class="n">the</span> <span class="n">default</span><span class="o">.</span>
</pre></div>
</div>
<p>The optimal number is of course system dependent. The following code
shows how to write and read a MultiFab.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>const std::string name {&quot;state&quot;};

VisMF::Write(mf, name);  // Write MultiFab to disk

// Read the data to a new MultiFab
// WARNING: mf2 may have a completely different DistributionMapping!
MultiFab mf2;
VisMF::Read(mf2, name);

// Read the data to a MultiFab with identical
// BoxArray, DistributionMapping, and number of components and ghost cells.
MultiFab mf3(mf.boxArray(), mf.DistributionMap(), mf.nComp(), mf.nGrow());
VisMF::Read(mf3, name);
</pre></div>
</div>
<p>It should be emphasized that calling VisMF::Read with an empty
MultiFab (i.e., no memory allocated for floating point data)
will result in a MultiFab with a new DistributionMapping
that could be different from any other existing DistributionMapping objects. It should also be noted that all the
data including those in ghost cells are written/read by VisMF::Write/Read.</p>
</div>
</div>
<div class="section" id="memory-allocation">
<h1>Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h1>
<p>&nbsp;has a Fortran module, mempool_module that can be used to
allocate memory for Fortran pointers. The reason that such a module
exists in &nbsp;is memory allocation is often very slow in
multi-threaded OpenMP parallel regions. &nbsp;mempool_module
provides a much faster alternative approach, in which each thread has
its own memory pool. Here are examples of using the module.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>use mempool_module, only : bl_allocate, bl_deallocate
real(amrex_real), pointer, contiguous :: a(:,:,:), b(:,:,:,:)
integer :: lo1, hi1, lo2, hi2, lo3, hi3, lo(4), hi(4)
! lo1 = ...
! a(lo1:hi1, lo2:hi2, lo3:hi3)
call bl_allocate(a, lo1, hi1, lo2, hi2, lo3, hi3)
! b(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),lo(4):hi(4))
call bl_allocate(b, lo, hi)
! ......
call bl_deallocate(a)
call bl_deallocate(b)
</pre></div>
</div>
<p>The downside of this is we have to use pointer instead of allocatable. This means we must explicitly free the memory via bl_deallocate and we need to declare the pointers as contiguous for performance reason.</p>
</div>
<div class="section" id="abort-and-assertion">
<h1>Abort and Assertion<a class="headerlink" href="#abort-and-assertion" title="Permalink to this headline">¶</a></h1>
<p>amrex::Abort(const char* message) is used to terminate a run
usually when something goes wrong. This function takes a message and
write it to stderr. Files named like Backtrace.rg_1_rl_1
(where rg_1_rl_1 means process 1) are produced containing
backtrace information of the call stack. In Fortran, we can call amrex_abort from the amrex_error_module, which takes a
Fortran character variable with assumed size (i.e., len=*)
as a message.</p>
<p>AMREX_ASSERT is a macro that takes a Boolean expression. For
debug build (e.g., DEBUG=TRUE using the GNU Make build system),
if the expression at runtime is evaluated to false, amrex::Abort
will be called and the run is thus terminated. For optimized build
(e.g., DEBUG=FALSE using the GNU Make build system), the AMREX_ASSERT statement is removed at compile time and thus has no
effect at runtime. We often use this as a means of putting debug
statement in the code without adding any extra cost for production
runs. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">AMREX_ASSERT</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">nGrow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mf</span><span class="o">.</span><span class="n">nComp</span><span class="p">()</span> <span class="o">==</span> <span class="n">mf2</span><span class="o">.</span><span class="n">nComp</span><span class="p">());</span>
</pre></div>
</div>
<p>Here for debug build we like to assert that MultiFab mf
has ghost cells and it also has the same number of components as MultiFab mf2. If we always want the assertion, we can use AMREX_ALWAYS_ASSERT.</p>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Boundary.html" class="btn btn-neutral float-right" title="Boundary Conditions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Chapter4.html" class="btn btn-neutral" title="Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, AMReX Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'10.17',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>