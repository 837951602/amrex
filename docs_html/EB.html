

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview of Embedded Boundary Description &mdash; amrex 18.09-dev documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Visualization" href="Chapter11.html" />
    <link rel="prev" title="Embedded Boundaries" href="Chapter10.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                18.09-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter2.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter4.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter5.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter6.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter6a.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter7.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter8.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter9.html">Fortran Interface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Chapter10.html">Embedded Boundaries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Overview of Embedded Boundary Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-volume-discretizations">Finite Volume Discretizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#small-cells-and-stability">Small Cells And Stability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-the-geometric-database">Initializing the Geometric Database</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-spherical-eb">Example: Spherical EB</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#other-basic-shapes">Other basic shapes:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-function-transformation-tools">Implicit Function Transformation Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-sphere-example">Multi-sphere example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric-example-2-surface-of-revolution">Geometric example 2 – Surface of revolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric-example-3-a-sphere-inside-a-parabola">Geometric example 3 – A Sphere Inside a Parabola</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ebfarraybox">EBFarrayBox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ebfarraybox-usage-example">EBFarrayBox Usage Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fortran-code-snippets">Fortran code Snippets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-data-is-cell-centered-even-cut-cells">The data is cell-centered, even cut cells</a></li>
<li class="toctree-l4"><a class="reference internal" href="#many-eb-operations-can-be-organized-as-post-processing">Many EB operations can be organized as post-processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-flag-data">The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">flag</span></span></code> data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#there-are-many-approaches">There are many approaches</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Chapter11.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter12.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter13.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter14.html">CVODE</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Chapter10.html">Embedded Boundaries</a> &raquo;</li>
        
      <li>Overview of Embedded Boundary Description</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/EB.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview-of-embedded-boundary-description">
<span id="sec-eb-eboverview"></span><h1>Overview of Embedded Boundary Description<a class="headerlink" href="#overview-of-embedded-boundary-description" title="Permalink to this headline">¶</a></h1>
<p>For computations with complex geometries, AMReX provides data structures and
algorithms to employ an embedded boundary (EB) approach to PDE discretizations.
In this approach, the underlying computational mesh is uniform and
block-structured, but the boundary of the irregular-shaped computational domain
conceptually cuts through this mesh. Each cell in the mesh becomes labeled as
regular, cut or covered, and the finite-volume based discretization methods
traditionally used in AMReX applications can be modified to incorporate these
cell shapes. See <a class="reference internal" href="#fig-ebexample"><span class="std std-numref">Fig. 10</span></a> for an illustration.</p>
<div class="figure" id="id1">
<span id="fig-ebexample"></span><a class="reference internal image-reference" href="_images/EB_example.png"><img alt="_images/EB_example.png" src="_images/EB_example.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">: In the embedded boundary approach to discretizing PDEs, the (uniform)
rectangular mesh is cut by the irregular shape of the computational domain.
The cells in the mesh are label as regular, cut or covered.</span></p>
</div>
<p>Because this is a relatively simple grid generation technique, computational
meshes for rather complex geometries can be generated quickly and robustly.
However, the technique can produce arbitrarily small cut cells in the domain.
In practice such small cells can have significant impact on the robustness and
stability of traditional finite volume methods. In this chapter we overview a
class of approaches to deal with this “small cell” problem in a robust and
efficient way, and discuss the tools and data that AMReX provides in order to
implement them.</p>
<p>Note that in a completely general implementation of the EB approach, there
would be no restrictions on the shape or complexity of the EB surface.  With
this generality comes the possibility that the process of “cutting” the cells
results in a single <span class="math notranslate nohighlight">\((i,j,k)\)</span> cell being broken into multiple cell
fragments.  The current release of AMReX does not support multi-valued cells,
thus there is a practical restriction on the complexity of domains (and
numerical algorithms) supported.</p>
<p>This chapter discusses the EB tools, data structures and algorithms currently
supported by AMReX to enable the construction of discretizations of
conservation law systems. The discussion will focus on general requirements
associated with building fluxes and taking divergences of them to advance such
systems. We also give examples of how to initialize the geometry data
structures and access them to build the numerical difference
operators.  Finally we present EB support of linear solvers.</p>
<div class="section" id="finite-volume-discretizations">
<h2>Finite Volume Discretizations<a class="headerlink" href="#finite-volume-discretizations" title="Permalink to this headline">¶</a></h2>
<p>Consider a system of PDEs to advance a conserved quantity <span class="math notranslate nohighlight">\(U\)</span> with fluxes
<span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eqn-hypsys">
<span class="eqno">(2)<a class="headerlink" href="#equation-eqn-hypsys" title="Permalink to this equation">¶</a></span>\[\frac{\partial U}{\partial t} + \nabla \cdot F = 0.\]</div>
<p>A conservative, finite volume discretization starts with the divergence theorm</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot F dV = \int_{\partial V} F \cdot n dA.\]</div>
<p>In an embedded boundary cell, the “conservative divergence” is discretized (as
<span class="math notranslate nohighlight">\(D^c(F)\)</span>) as follows</p>
<div class="math notranslate nohighlight" id="equation-eqn-ebdiv">
<span class="eqno">(3)<a class="headerlink" href="#equation-eqn-ebdiv" title="Permalink to this equation">¶</a></span>\[ D^c(F) = \frac{1}{\kappa h} \left( \sum^D_{d = 1}
   (F_{d, \mathrm{hi}} \, \alpha_{d, \mathrm{hi}} - F_{d, \mathrm{lo}}\, \alpha_{d, \mathrm{lo}})
   + F^{EB} \alpha^{EB} \right).\]</div>
<p>Geometry is discretely represented by volumes (<span class="math notranslate nohighlight">\(V = \kappa h^d\)</span>) and
apertures (<span class="math notranslate nohighlight">\(A= \alpha h^{d-1}\)</span>), where <span class="math notranslate nohighlight">\(h\)</span> is the (uniform) mesh
spacing at that AMR level, <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction and
<span class="math notranslate nohighlight">\(\alpha\)</span> are the area fractions.  Without multivalued cells the volume
fractions, area fractions and cell and face centroids (see
<a class="reference internal" href="#fig-volume"><span class="std std-numref">Table 8</span></a>) are the only geometric information needed to compute
second-order fluxes centered at the face centroids, and to infer the
connectivity of the cells.  Cells are connected if adjacent on the Cartesian
mesh, and only via coordinate-aligned faces on the mesh. If an aperture,
<span class="math notranslate nohighlight">\(\alpha = 0\)</span>, between two cells, they are not directly connected to each
other.</p>
<span id="fig-volume"></span><table border="1" class="docutils align-center" id="id2">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">Illustration of embedded boundary cutting a two-dimensional cell.</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/areas_and_volumes.png"><img alt="a" src="_images/areas_and_volumes.png" style="width: 100%;" /></a></td>
<td><a class="reference internal" href="_images/eb_fluxes.png"><img alt="b" src="_images/eb_fluxes.png" style="width: 100%;" /></a></td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">A typical two-dimensional uniform cell that is</div>
<div class="line">cut by the embedded boundary. The grey area</div>
<div class="line">represents the region excluded from the</div>
<div class="line">calculation. The portion of the cell faces</div>
<div class="line">faces (labelled with A) through which fluxes</div>
<div class="line">flow are the “uncovered” regions of the full</div>
<div class="line">cell faces. The volume (labelled V) is the</div>
<div class="line">uncovered region of the interior.</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Fluxes in a cut cell.</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="small-cells-and-stability">
<h2>Small Cells And Stability<a class="headerlink" href="#small-cells-and-stability" title="Permalink to this headline">¶</a></h2>
<p>In the context of time-explicit advance methods for, say hyperbolic
conservation laws, a naive discretization in time of <a class="reference internal" href="#equation-eqn-hypsys">(2)</a> using
<a class="reference internal" href="#equation-eqn-ebdiv">(3)</a>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1} = U^{n} - \delta t D^c(F)\]</div>
<p>would have a time step constraint <span class="math notranslate nohighlight">\(\delta t \sim h \kappa^{1/D}/V_m\)</span>,
which goes to zero as the size of the smallest volume fraction <span class="math notranslate nohighlight">\(\kappa\)</span>
in the calculation. Since EB volume fractions can be arbitrarily small, this is
an unacceptable constraint. One way to remedy this is to create
“non-conservative” approximation to the divergence <span class="math notranslate nohighlight">\(D^{nc}\)</span>, which at a
cell <span class="math notranslate nohighlight">\({\bf i}\)</span>, can be formed as an average of the conservative
divergences in the neighborhood, <span class="math notranslate nohighlight">\(N_{\bf i}\)</span>, of <span class="math notranslate nohighlight">\({\bf i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[D^{nc}(F)_{\bf i}= \frac{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}D(F)_{\bf j}}{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}}\]</div>
<p>Incorporating this form, the solution can be updated using a <em>hybrid
divergence</em>, <span class="math notranslate nohighlight">\(D^H(F) = \kappa D^c(F) + (1-\kappa)D^{nc}\)</span>:</p>
<div class="math notranslate nohighlight">
\[U^{n+1,*} = U^n - \delta t D^H(F)\]</div>
<p>However, we would like our finite-volume scheme to strictly conserve the field
quantities over the domain. To enforce this, we calculate <span class="math notranslate nohighlight">\(\delta M\)</span>, the
mass gained or lost by not using <span class="math notranslate nohighlight">\(D^c\)</span> directly,</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \kappa (1-\kappa)(D^c(F)_{\bf i}- D^{nc}(F)_{\bf i})\]</div>
<p>This “excess material” (mass, if <span class="math notranslate nohighlight">\(U=\rho\)</span>) can be <em>redistributed</em> in a
time-explicit fashion to neighboring cells, <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \sum_{{\bf j}\in N_{\bf i}} \delta M_{{\bf j}, {\bf i}}.\]</div>
<p>in order to preserve strict conservation over <span class="math notranslate nohighlight">\(N_{\bf i}\)</span>.</p>
<p>Note that the physics at hand may impact the optimal choice of precisely how
the excess mass is distributed in this fashion. We introduce a weighting for
redistribution, <span class="math notranslate nohighlight">\(W\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-eqn-massweight">
<span class="eqno">(4)<a class="headerlink" href="#equation-eqn-massweight" title="Permalink to this equation">¶</a></span>\[ \delta M_{{\bf j}, {\bf i}} =  \frac{\delta M_{\bf i}\kappa_{\bf j}
   W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}\]</div>
<p>For all <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1}_{\bf j}= U^{n+1,*}_{\bf j}+
 \frac{\delta M_{\bf i}
  W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}.\]</div>
<p>Typically, the redistribution neighborhood for each cell is one that can be
reached via a monotonic path in each coordinate direction of unit length (see,
e.g., <a class="reference internal" href="#fig-redistribution"><span class="std std-numref">Fig. 11</span></a>)</p>
<div class="figure" id="id3">
<span id="fig-redistribution"></span><a class="reference internal image-reference" href="_images/redist.png"><img alt="_images/redist.png" src="_images/redist.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">: Redistribution illustration. Excess mass due to using a hybrid divergence
<span class="math notranslate nohighlight">\(D^H\)</span> instead of the conservative divergence <span class="math notranslate nohighlight">\(D^C\)</span> is
distributed to neighbor cells.</span></p>
</div>
</div>
</div>
<div class="section" id="initializing-the-geometric-database">
<span id="sec-eb-ebinit"></span><h1>Initializing the Geometric Database<a class="headerlink" href="#initializing-the-geometric-database" title="Permalink to this headline">¶</a></h1>
<p>In AMReX the geometric information is stored in a distributed database
class that must be initialized at the start of the calculation.  The
procedure for this goes as follows:</p>
<ul class="simple">
<li>Define function of position which describes the surface and use it define a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code> object – specifically, the scalar value returned by this
function takes on a negative value inside the fluid, a positive value in the
body, and identically zero at the EB.</li>
<li>Construct an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBIndexSpace</span></span></code> with the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code> object. This
will fill the underlying database of geometric information, specifically
tailored to the actual meshes that will be used. Thus, the construction
requires one to specify the actual mesh resolution that will be used in a
calculation.</li>
<li><dl class="first docutils">
<dt>If one wants to archive the geometric data for later runs, they can</dt>
<dd>call EBIndexSpace::write to put the data into a file.  One must be
cautious, however, since these plot files are not binary portable.
An EBIndexSpace plot file generated on one machine won’t
necessarily work on another machine.</dd>
</dl>
</li>
</ul>
<blockquote>
<div><dl class="docutils">
<dt>To facilitate the generation step,</dt>
<dd>AMReX defines a virtual class, an “implicit function”,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseIF</span></span></code>, which encapsulates this functionality.  An instance
of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseIF</span></span></code> object is required for the construction of a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code> object.</dd>
</dl>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GeometryShop</span><span class="p">(</span><span class="k">const</span> <span class="n">BaseIF</span><span class="o">&amp;</span> <span class="n">a_localGeom</span><span class="p">)</span>
</pre></div>
</div>
<p>Although the user is free to define their own instance of this class, AMReX
provides a number of preconfigured useful ones. This are listed in the next
section.</p>
<div class="section" id="example-spherical-eb">
<h2>Example: Spherical EB<a class="headerlink" href="#example-spherical-eb" title="Permalink to this headline">¶</a></h2>
<p>The spherical implicit function, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">SphereIF</span></span></code>, derives from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseIF</span></span></code>,
and defines the function</p>
<div class="math notranslate nohighlight">
\[S({\bf x}) = x^2 + y^2 + z^2 - R^2,\]</div>
<p>In this case, the solution domain is defined as the interior of a sphere of
radius <span class="math notranslate nohighlight">\(R\)</span>. If the sign of <span class="math notranslate nohighlight">\(S\)</span> is reversed, the solution domain is
the exterior of the sphere. The following example illustrates how to use the
SphereIF&nbsp;class to define a GeometryShop&nbsp;object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">IntVect</span><span class="o">::</span><span class="n">Unit</span><span class="p">);</span>
<span class="n">Real</span> <span class="n">dx</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">nx</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">RealVect</span> <span class="n">center</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">RealVect</span><span class="o">::</span><span class="n">Unit</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">insideRegular</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="c1">//this is the implicit function</span>
<span class="n">SphereIF</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">insideRegular</span><span class="p">);</span>

<span class="c1">//this is worker object that creates geometric information given an IF</span>
<span class="n">GeometryShop</span> <span class="nf">workshop</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>

<span class="c1">//this is the global, distributed database being initialized</span>
<span class="n">EBIndexSpace</span><span class="o">*</span>  <span class="n">ebis</span> <span class="o">=</span> <span class="n">AMReX_EBIS</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
<span class="n">ebis</span><span class="o">-&gt;</span><span class="n">define</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">workshop</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, we construct an <span class="math notranslate nohighlight">\(r=0.1\)</span> sphere, centered within a unit
cube. The mesh resolution is <span class="math notranslate nohighlight">\(1024^3\)</span>.  The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code>&nbsp;object
based on this sphere is then used to construct the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBIndexSpace</span></span></code>, as
shown.</p>
<div class="section" id="other-basic-shapes">
<h3>Other basic shapes:<a class="headerlink" href="#other-basic-shapes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Planes are made using the class <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">PlaneIF</span></span></code> which given a normal
<span class="math notranslate nohighlight">\({\bf n}\)</span> and a center <span class="math notranslate nohighlight">\({\bf c}\)</span> gives the implicit function</p>
<div class="math notranslate nohighlight">
\[I({\bf x}) = \sum_{1&lt;=d&lt;=D} n_d (x_d - c_d).\]</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RealVect</span> <span class="n">normal</span><span class="p">;</span>
<span class="n">RealVect</span> <span class="n">center</span><span class="p">;</span>
<span class="c1">// ...fill in values for normal and centre...</span>

<span class="n">PlaneIF</span> <span class="nf">plane</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">centre</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">GeometryShop</span> <span class="nf">workshop</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>

<span class="n">EBIndexSpace</span><span class="o">*</span>  <span class="n">ebis</span> <span class="o">=</span> <span class="n">AMReX_EBIS</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
<span class="n">ebis</span><span class="o">-&gt;</span><span class="n">define</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">workshop</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Polynomials of any form can be made using the class
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">PolynomialIF</span></span></code>. Here is an example that makes a parabola of
the form <span class="math notranslate nohighlight">\(I({\bf x}) = x - y^2 - z^2\)</span>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">PolyTerm</span><span class="o">&gt;</span> <span class="n">poly</span><span class="p">;</span>
<span class="n">PolyTerm</span> <span class="n">mono</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">IntVect</span> <span class="n">powers</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">amplitude</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// y^2 term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">;</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>
<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="c1">// z^2 term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">;</span>
<span class="n">RealVect</span> <span class="n">translation</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idir</span> <span class="o">&lt;</span> <span class="n">SpaceDim</span><span class="p">;</span> <span class="n">idir</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">finesize</span> <span class="o">=</span> <span class="n">finest_domain</span><span class="p">.</span><span class="n">size</span><span class="p">()[</span><span class="n">idir</span><span class="p">];</span>
    <span class="n">translation</span><span class="p">[</span><span class="n">idir</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">finesize</span><span class="o">*</span><span class="n">fine_dx</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">TransformIF</span> <span class="nf">implicit</span><span class="p">(</span><span class="n">mirror</span><span class="p">);</span>
<span class="n">implicit</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">translation</span><span class="p">);</span>
<span class="n">impfunc</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">implicit</span><span class="p">.</span><span class="n">newImplicitFunction</span><span class="p">());</span>

<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>
<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="c1">// x term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>

<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="n">PolynomialIF</span> <span class="nf">mirror</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="n">GeometryShop</span> <span class="nf">workshop</span><span class="p">(</span><span class="n">mirror</span><span class="p">)</span>
<span class="n">EBIndexSpace</span><span class="o">*</span>  <span class="n">ebis</span> <span class="o">=</span> <span class="n">AMReX_EBIS</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
<span class="n">ebis</span><span class="o">-&gt;</span><span class="n">define</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">workshop</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="implicit-function-transformation-tools">
<h2>Implicit Function Transformation Tools<a class="headerlink" href="#implicit-function-transformation-tools" title="Permalink to this headline">¶</a></h2>
<p>More complex domains can be constructed by composing these fundamental shapes.
AMReX contains the following classes to compose implicit functions:</p>
<ul class="simple">
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">TransformIF</span></span></code> allows for translations and rotations of an implicit function.</li>
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">UnionIF</span></span></code> produces the union of two implicit functions.</li>
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntersectionIF</span></span></code> produces the intersection of two implicit functions.</li>
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LatheIF</span></span></code> creates a 3D implicit function as the surface of
revolution of a 2D implicit function.</li>
</ul>
</div>
<div class="section" id="multi-sphere-example">
<h2>Multi-sphere example<a class="headerlink" href="#multi-sphere-example" title="Permalink to this headline">¶</a></h2>
<p>The following example creates a geometry using multiple spheres:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span>     <span class="n">radius</span><span class="p">(</span><span class="n">numSpheres</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">RealVect</span><span class="o">&gt;</span> <span class="n">center</span><span class="p">(</span><span class="n">numSpheres</span><span class="p">);</span>
<span class="c1">//...</span>

<span class="c1">//create an implicit function for each sphere</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseIF</span><span class="o">*&gt;</span>  <span class="n">spheres</span><span class="p">(</span><span class="n">numSpheres</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">isphere</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">isphere</span> <span class="o">&lt;</span> <span class="n">numSpheres</span><span class="p">;</span> <span class="n">isphere</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Create sphere at each origin and translate</span>
  <span class="n">SphereIF</span> <span class="n">sphereAtZero</span><span class="p">(</span><span class="n">radius</span><span class="p">[</span><span class="n">isphere</span><span class="p">],</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">TransformIF</span><span class="o">*</span> <span class="n">movedSphere</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TransformIF</span><span class="p">(</span><span class="n">sphereAtZero</span><span class="p">);</span>
  <span class="n">movedSphere</span><span class="o">-&gt;</span><span class="n">translate</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">isphere</span><span class="p">]);</span>
  <span class="n">spheres</span><span class="p">[</span><span class="n">isphere</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BaseIF</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">movedSphere</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Create implicit function as intersection of spheres</span>
<span class="n">IntersectionIF</span> <span class="n">impMultisphere</span><span class="p">(</span><span class="n">spheres</span><span class="p">);</span>

<span class="c1">// Fluid will in the complement space outside the sphere</span>
<span class="n">ComplementIF</span> <span class="nf">sideImpMultisphere</span><span class="p">(</span><span class="n">impMultisphere</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

<span class="c1">// Construct the geometryshop</span>
<span class="n">GeometryShop</span> <span class="n">workshop</span><span class="p">(</span><span class="n">sideImpMultisphere</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="geometric-example-2-surface-of-revolution">
<h2>Geometric example 2 – Surface of revolution<a class="headerlink" href="#geometric-example-2-surface-of-revolution" title="Permalink to this headline">¶</a></h2>
<p>Here is an example that creates a geometric construction using a surface of
revolution of a set of polygons. This particular example only makes sense in
three dimensions. With the right polygons, it creates the surface shown in
<a class="reference internal" href="#fig-revolution"><span class="std std-numref">Fig. 12</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// define EBIndexSpace from the surface of revolution of a set of polygons</span>
<span class="kt">void</span>
<span class="nf">defineGeometry</span><span class="p">(</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;</span> <span class="n">fine_dx</span><span class="p">,</span> <span class="k">const</span>  <span class="n">Box</span><span class="o">&amp;</span> <span class="n">finest_domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_grid_size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;creating geometry from polygon surfaces of revolution&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="c1">// These  the polygons that get built around the z axis</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">RealVect</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">polygons</span><span class="p">;</span>
  <span class="c1">//....fill the polygons any way you like//</span>

  <span class="c1">// Make the Vector of (convex) polygons (Vectors of points) into a union</span>
  <span class="c1">// of convex polygons, each made from the intersection of a set of half</span>
  <span class="c1">// planes/spaces - all represented by implicit functions.</span>

  <span class="c1">// A list of all the polygons as implicit functions</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BaseIF</span><span class="o">*&gt;</span> <span class="n">polytopes</span><span class="p">;</span>
  <span class="n">polytopes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">numPolys</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="c1">// Process each polygon</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">numPolys</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// All the half planes/spaces used to make a polygon</span>
    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BaseIF</span><span class="o">*&gt;</span> <span class="n">planes</span><span class="p">;</span>
    <span class="n">planes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Get the current polygon (as a Vector of points)</span>
    <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">RealVect</span><span class="o">&gt;&amp;</span> <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>

    <span class="c1">// Get the number of points in the polygon</span>
    <span class="kt">int</span> <span class="n">numPts</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="c1">// Process each pair of points</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">numPts</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// The normal and point is space used to specify each half plane/space</span>
      <span class="n">RealVect</span> <span class="n">normal</span><span class="p">(</span><span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">);</span>
      <span class="n">RealVect</span> <span class="n">point</span><span class="p">;</span>

      <span class="c1">// Set the normal remembering that the last point connects to the first</span>
      <span class="c1">// point.</span>
      <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">polygon</span><span class="p">[(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numPts</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">polygon</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
      <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">polygon</span><span class="p">[(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numPts</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">polygon</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

      <span class="n">point</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

      <span class="c1">// Generate the appropriate half plane/space (as an implicit function)</span>
      <span class="n">PlaneIF</span><span class="o">*</span> <span class="n">plane</span><span class="p">;</span>
      <span class="n">plane</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PlaneIF</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">point</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

      <span class="c1">// Save the result</span>
      <span class="n">planes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">plane</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Intersect all the half planes/spaces to create an implicit function</span>
    <span class="c1">// that represents the polygon</span>
    <span class="n">IntersectionIF</span><span class="o">*</span> <span class="n">polygonIF</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntersectionIF</span><span class="p">(</span><span class="n">planes</span><span class="p">);</span>

    <span class="n">polytopes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">polygonIF</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//this makes the cross section the union of all the polygons (around</span>
  <span class="c1">//z-axis, recall)</span>
  <span class="n">UnionIF</span> <span class="n">crossSection</span><span class="p">(</span><span class="n">polytopes</span><span class="p">);</span>

  <span class="c1">// In 3D rotate about the z-axis</span>
  <span class="n">LatheIF</span> <span class="n">lathe</span><span class="p">(</span><span class="n">crossSection</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

  <span class="c1">//we are starting around the z axis so we need to translate</span>
  <span class="c1">//over to the center of the x-y plane</span>

  <span class="n">RealVect</span> <span class="n">translation</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idir</span> <span class="o">&lt;</span> <span class="n">SpaceDim</span><span class="p">;</span> <span class="n">idir</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">translation</span><span class="p">[</span><span class="n">idir</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">finest_domain</span><span class="p">.</span><span class="n">size</span><span class="p">()[</span><span class="n">idir</span><span class="p">]</span><span class="o">*</span><span class="n">fine_dx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">translation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">TransformIF</span> <span class="n">implicit</span><span class="p">(</span><span class="n">lathe</span><span class="p">);</span>
  <span class="n">implicit</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">translation</span><span class="p">);</span>

  <span class="c1">//create a workshop from translated surface of revolution</span>
  <span class="n">GeometryShop</span> <span class="n">gshop</span><span class="p">(</span><span class="n">implicit</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="c1">//define the geometric database</span>
  <span class="n">AMReX_EBIS</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">define</span><span class="p">(</span><span class="n">finest_domain</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span>
                                 <span class="n">fine_dx</span><span class="p">,</span> <span class="n">gshop</span><span class="p">,</span> <span class="n">max_grid_size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="figure" id="id4">
<span id="fig-revolution"></span><a class="reference internal image-reference" href="_images/revolution.png"><img alt="_images/revolution.png" src="_images/revolution.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">: Zero surface of an implicit function made using a surface of revolution.</span></p>
</div>
</div>
<div class="section" id="geometric-example-3-a-sphere-inside-a-parabola">
<h2>Geometric example 3 – A Sphere Inside a Parabola<a class="headerlink" href="#geometric-example-3-a-sphere-inside-a-parabola" title="Permalink to this headline">¶</a></h2>
<p>Here is an example that creates a geometry of a sphere contained within a
parabola. This code creates the surface shown in <a class="reference internal" href="#fig-parabolasphere"><span class="std std-numref">Fig. 13</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">PolyTerm</span><span class="o">&gt;</span> <span class="n">poly</span><span class="p">;</span>

<span class="n">PolyTerm</span> <span class="n">mono</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">IntVect</span> <span class="n">powers</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">amplitude</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// y^2 term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">;</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>

<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="c1">// z^2 term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">;</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>
<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="c1">// x term</span>
<span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">;</span>
<span class="n">powers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">coef</span>   <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="n">mono</span><span class="p">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span><span class="p">;</span>

<span class="n">poly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mono</span><span class="p">);</span>

<span class="n">PolynomialIF</span> <span class="nf">mirror</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="n">RealVect</span> <span class="n">translation</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idir</span> <span class="o">&lt;</span> <span class="n">SpaceDim</span><span class="p">;</span> <span class="n">idir</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">finesize</span> <span class="o">=</span> <span class="n">finest_domain</span><span class="p">.</span><span class="n">size</span><span class="p">()[</span><span class="n">idir</span><span class="p">];</span>
  <span class="n">translation</span><span class="p">[</span><span class="n">idir</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">finesize</span><span class="o">*</span><span class="n">fine_dx</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">RealVect</span> <span class="n">center</span> <span class="o">=</span> <span class="n">translation</span><span class="p">;</span>
<span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">TransformIF</span> <span class="nf">transform</span><span class="p">(</span><span class="n">mirror</span><span class="p">);</span>
<span class="n">transform</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">translation</span><span class="p">);</span>

<span class="n">Real</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">SphereIF</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">BaseIF</span><span class="o">*&gt;</span> <span class="n">funcs</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">;</span>
<span class="n">funcs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sphere</span><span class="p">;</span>
<span class="n">UnionIF</span> <span class="nf">implicit</span><span class="p">(</span><span class="n">funcs</span><span class="p">);</span>
<span class="n">impfunc</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">implicit</span><span class="p">.</span><span class="n">newImplicitFunction</span><span class="p">());</span>
<span class="n">GeometryShop</span> <span class="nf">gshop</span><span class="p">(</span><span class="n">impfunc</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="c1">//define the geometric database</span>
<span class="n">AMReX_EBIS</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">define</span><span class="p">(</span><span class="n">finest_domain</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span>
                                 <span class="n">fine_dx</span><span class="p">,</span> <span class="n">gshop</span><span class="p">,</span> <span class="n">max_grid_size</span><span class="p">);</span>
</pre></div>
</div>
<div class="figure" id="id5">
<span id="fig-parabolasphere"></span><a class="reference internal image-reference" href="_images/parabsphere.png"><img alt="_images/parabsphere.png" src="_images/parabsphere.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">: Zero surface of an implicit function made the above code.</span></p>
</div>
</div>
</div>
<div class="section" id="ebfarraybox">
<h1>EBFarrayBox<a class="headerlink" href="#ebfarraybox" title="Permalink to this headline">¶</a></h1>
<p>The fundamental data structure for embedded boundary calculations is
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBox</span></span></code>. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBox</span></span></code> is an a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> with two extra
data members.</p>
<ul class="simple">
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBox</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">getEBISBox</span></span></code> returns an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBISBox</span></span></code>, a data structure
that contains the geometric information of an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBIndexSpace</span></span></code>&nbsp;but
restricted to a given box.</li>
<li><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBox</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">getEBCellFlagFab</span></span></code> is a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">EBCellFlag</span></span><span class="operator"><span class="pre">&gt;</span></span></code>, where
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlag</span></span></code> is a class which is a class with tools that compactly
specifies local cell connectivities on a box.</li>
</ul>
<p>If one compiles with <code class="docutils literal notranslate"><span class="pre">AMREX_USE_EB</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>, the state data managed by the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Amr</span></span></code> class is automatically of type <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBox</span></span></code> (typically the
data is exposed explicitly as a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, but the additional
functionality may be accessed through a C++ type cast. The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code>
can be used down in Fortran, e.g., to choose locally whether EB-specific
operations and data are required for constructing discretizations. In the next
section, we show examples of this workflow.</p>
<div class="section" id="ebfarraybox-usage-example">
<h2>EBFarrayBox Usage Example<a class="headerlink" href="#ebfarraybox-usage-example" title="Permalink to this headline">¶</a></h2>
<p>In order to make these EB concepts more concrete, we discuss here sample code
that appears in the AMReX tutorial, <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/CNS</span></code>. This code implements a
time-explicit second-order method of lines integrator for hyperbolic and
parabolic transport based on a gamma-law gas EOS and constant transport
properties. This example also demonstrates how to avoid the more
complex/expensive EB-related logic if the tile under consideration has no cut
cells.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="n">CNS</span><span class="o">::</span><span class="n">compute_dSdt</span> <span class="p">(</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">S</span><span class="p">,</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">dSdt</span><span class="p">,</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">,</span>
                   <span class="n">EBFluxRegister</span><span class="o">*</span> <span class="n">fr_as_crse</span><span class="p">,</span> <span class="n">EBFluxRegister</span><span class="o">*</span> <span class="n">fr_as_fine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BL_PROFILE</span><span class="p">(</span><span class="s">&quot;CNS::compute_dSdt()&quot;</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Real</span><span class="o">*</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">CellSize</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">dSdt</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>

<span class="cp">#ifdef _OPENMP</span>
<span class="cp">#pragma omp parallel</span>
<span class="cp">#endif</span>
     <span class="p">{</span>
        <span class="c1">//fluxes for the advance</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">flux</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">MFItInfo</span><span class="p">().</span><span class="n">EnableTiling</span><span class="p">(</span><span class="n">hydro_tile_size</span><span class="p">).</span><span class="n">SetDynamic</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
                        <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//this tile is the subset of the box over which we are computing</span>
            <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>

            <span class="c1">//because S was created with the EBFArrayBoxFactory, we can do this cast</span>
            <span class="k">const</span> <span class="n">EBFArrayBox</span><span class="o">&amp;</span> <span class="n">sfab</span>
                <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">EBFArrayBox</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">mfi</span><span class="p">]);</span>

            <span class="c1">//here we are getting the collection of flags so we know</span>
            <span class="c1">//kind of grid this is and if it is an EB grid, we have</span>
            <span class="c1">//the connectivity info</span>
            <span class="k">const</span> <span class="n">EBCellFlagFab</span> <span class="o">&amp;</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">sfab</span><span class="p">.</span><span class="n">getEBCellFlagFab</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">getType</span><span class="p">(</span><span class="n">bx</span><span class="p">)</span> <span class="o">==</span> <span class="n">FabType</span><span class="o">::</span><span class="n">covered</span><span class="p">)</span>
            <span class="p">{</span>
              <span class="c1">//this tile is covered so there are no meaningful data here</span>
                <span class="n">dSdt</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
              <span class="c1">//create the flux holders for this tile</span>
              <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idim</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span>
              <span class="p">{</span>
                <span class="n">flux</span><span class="p">[</span><span class="n">idim</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">surroundingNodes</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span><span class="n">idim</span><span class="p">),</span><span class="n">ncomp</span><span class="p">);</span>
              <span class="p">}</span>

              <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">getType</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">grow</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">FabType</span><span class="o">::</span><span class="n">regular</span><span class="p">)</span>
              <span class="p">{</span>
                <span class="c1">//this tile has no cut cells so we can just proceed</span>
                <span class="c1">//with a (cheaper) non-eb call</span>

                <span class="n">cns_compute_dudt</span><span class="p">(</span><span class="n">BL_TO_FORTRAN_BOX</span><span class="p">(</span><span class="n">bx</span><span class="p">),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">dSdt</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="n">dx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>

              <span class="p">}</span>
              <span class="k">else</span>
              <span class="p">{</span>
                <span class="c1">//this tile has cut cells so we have to send into Fortran</span>
                <span class="c1">//EBCellFlagFAB as well as lots of geometric</span>
                <span class="c1">//information</span>
                <span class="c1">//the areafrac and facecent objects are member data</span>
                <span class="c1">//filled using EBISBox</span>
                <span class="n">cns_eb_compute_dudt</span><span class="p">(</span><span class="n">BL_TO_FORTRAN_BOX</span><span class="p">(</span><span class="n">bx</span><span class="p">),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">dSdt</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">flag</span><span class="p">),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">volfrac</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">bndrycent</span><span class="p">[</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">areafrac</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">areafrac</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">areafrac</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">facecent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">facecent</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">facecent</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">mfi</span><span class="p">]),</span>
                <span class="n">dx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>This is the main loop in the routine to advance the state. The state,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">S</span></span></code>, comes into this routine with grow cells properly filled, and
this routine features a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> iterator loop to step through this
data, tile-by-tile and compute <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">dSdt</span></span></code>. Here, we see that the definition of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFarrayBox</span></span> <span class="name"><span class="pre">sfab</span></span></code> incorporates the aforementioned type cast, enabling
queries about the EB nature of the data. Of the two possiblities handled, the
“regular” type without cut cells has a much simpler interface. The EB version
takes all the same data, but additionally requires (dense) data to specify the
volume and face area fractions, centroid information, and the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span> <span class="name"><span class="pre">flag</span></span></code> structure that will be queried pointwise for the
local cell connectivity.</p>
</div>
<div class="section" id="fortran-code-snippets">
<h2>Fortran code Snippets<a class="headerlink" href="#fortran-code-snippets" title="Permalink to this headline">¶</a></h2>
<p>Much of the code to compute these fluxes and their divergence in this example
is too detailed to step through in this context. There are however a few
salient features worth pointing out.</p>
<div class="section" id="the-data-is-cell-centered-even-cut-cells">
<h3>The data is cell-centered, even cut cells<a class="headerlink" href="#the-data-is-cell-centered-even-cut-cells" title="Permalink to this headline">¶</a></h3>
<p>In order to simplify the construction second-order discretizations, we can base
all the numerical operations on the assumption that all cell-based data lives
at the center of the <em>full</em> &nbsp;cell containing the cut cells. This means that when
we take a standard centered difference between cell data at <span class="math notranslate nohighlight">\((i,j,k)\)</span> and
<span class="math notranslate nohighlight">\((i+1,j,k)\)</span>, e.g., we get a gradient value that is second-order and
centered on the full face at <span class="math notranslate nohighlight">\(i+1/2\)</span>, regardless of the aperature.</p>
</div>
<div class="section" id="many-eb-operations-can-be-organized-as-post-processing">
<h3>Many EB operations can be organized as post-processing<a class="headerlink" href="#many-eb-operations-can-be-organized-as-post-processing" title="Permalink to this headline">¶</a></h3>
<p>Recall that a second-order finite-volume scheme requires that fluxes be
centered on the face <em>centroid</em>. This can be accomplished by post-processing
face-centered fluxes with a linear interpolation of adjacent face values. The
resulting centroid-based fluxes are second-order, and can be used to construct
the conservative divergence we seek. Note that this operation requires the
location of the face centroids, and increases the grow cell requirement of the
flux operators, as does the necessity to form the <em>hybrid divergence</em> operator
discussed above.</p>
</div>
<div class="section" id="the-flag-data">
<h3>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">flag</span></span></code> data<a class="headerlink" href="#the-flag-data" title="Permalink to this headline">¶</a></h3>
<p>AMReX provides functions that query the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">flag</span></span></code> data in order to infer the
local connectivity of cells. For example, the cell itself or its neighbors may
be covered or cut. If cut, the data is centered at the center of the full cell.
If covered, the data is invalid and should not be involved in the fluid
advance. An example of such a call is:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">get_neighbor_cells</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">nbr</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, for the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">flag</span></span></code> at <span class="math notranslate nohighlight">\((i,j,k)\)</span> is used to fill a local
<span class="math notranslate nohighlight">\(3^3\)</span> array of integers with the value <span class="math notranslate nohighlight">\(1\)</span> if connected to
<span class="math notranslate nohighlight">\((i,j,k)\)</span>, and <span class="math notranslate nohighlight">\(0\)</span> if not. Similar queries:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">is_covered_cell</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
<span class="n">is_single_valued_cell</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>can be used to gather additional detail.</p>
<p>Below, we show a partial listing of the <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">cns_eb_compute_dudt</span></span></code> code,
specifically after the face-centered fluxes have been computed, and showing
part of the work necessary to interpolate them to face centroids (while
appropriately handling covered data).</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">do </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncomp</span>

   <span class="c">!</span>
   <span class="c">! First, we compute conservative divergence on (lo-2,hi+2)</span>
   <span class="c">!</span>
   <span class="n">iwall</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">do       </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
      <span class="k">do    </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
         <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
            <span class="n">divc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">dxinv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">&amp;</span>
                 <span class="o">+</span>        <span class="p">(</span><span class="n">fluxy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">fluxy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">dxinv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">&amp;</span>
                 <span class="o">+</span>        <span class="p">(</span><span class="n">fluxz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">fluxz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">dxinv</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
         <span class="k">end do</span>

<span class="k">         do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_covered_cell</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
<span class="k">               </span><span class="n">divc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.d0</span>
            <span class="k">else if</span> <span class="p">(</span><span class="n">is_single_valued_cell</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>

<span class="k">               call </span><span class="n">get_neighbor_cells</span><span class="p">(</span><span class="n">cellflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">nbr</span><span class="p">)</span>

               <span class="c">! x-direction lo face</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">apx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">).</span><span class="n">lt</span><span class="p">.</span><span class="mf">1.d0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">                  if</span> <span class="p">(</span><span class="n">centx_y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">).</span><span class="n">le</span><span class="p">.</span><span class="mf">0.d0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">                     </span><span class="n">fracy</span> <span class="o">=</span> <span class="o">-</span><span class="n">centx_y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                     <span class="k">if</span><span class="p">(</span><span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">).</span><span class="n">le</span><span class="p">.</span> <span class="mf">0.0d0</span><span class="p">)</span><span class="k">then</span>
<span class="k">                        </span><span class="n">fracz</span> <span class="o">=</span> <span class="o">-</span> <span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fxm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>      <span class="n">fracz</span> <span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
                     <span class="k">else</span>
<span class="k">                        </span><span class="n">fracz</span> <span class="o">=</span>  <span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fxm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>      <span class="n">fracz</span> <span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
                     <span class="n">endif</span>
                  <span class="k">else</span>
<span class="k">                     </span><span class="n">fracy</span> <span class="o">=</span> <span class="n">centx_y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                     <span class="k">if</span><span class="p">(</span><span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">).</span><span class="n">le</span><span class="p">.</span> <span class="mf">0.0d0</span><span class="p">)</span><span class="k">then</span>
<span class="k">                        </span><span class="n">fracz</span> <span class="o">=</span> <span class="o">-</span><span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fxm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>      <span class="n">fracz</span> <span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
                     <span class="k">else</span>
<span class="k">                        </span><span class="n">fracz</span> <span class="o">=</span> <span class="n">centx_z</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">nbr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fxm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span>  <span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>      <span class="n">fracz</span> <span class="o">*</span><span class="p">(</span>     <span class="n">fracy</span> <span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="o">+</span> <span class="p">&amp;</span>
                             <span class="p">&amp;</span>             <span class="p">(</span><span class="mf">1.d0</span><span class="o">-</span><span class="n">fracy</span><span class="p">)</span><span class="o">*</span><span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span>  <span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
                     <span class="n">endif</span>
                  <span class="k">end if</span>
<span class="k">               else</span>
<span class="k">                  </span><span class="n">fxm</span> <span class="o">=</span> <span class="n">fluxx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
               <span class="k">end if</span>

       <span class="o">&lt;</span><span class="p">.....</span> <span class="n">similar</span> <span class="n">code</span> <span class="n">for</span> <span class="n">other</span> <span class="n">fluxes</span> <span class="n">removed</span> <span class="p">....</span><span class="o">&gt;</span>

               <span class="n">iwall</span> <span class="o">=</span> <span class="n">iwall</span> <span class="o">+</span> <span class="mi">1</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">.</span><span class="n">eq</span><span class="p">.</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span>
<span class="k">                  call </span><span class="n">compute_hyp_wallflux</span><span class="p">(</span><span class="n">divhyp</span><span class="p">(:,</span><span class="n">iwall</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">qrho</span><span class="p">),</span> <span class="p">&amp;</span>
                       <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">qu</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">qv</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">qw</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">qp</span><span class="p">),</span> <span class="p">&amp;</span>
                       <span class="n">apx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">apx</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="p">&amp;</span>
                       <span class="n">apy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">apy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="p">&amp;</span>
                       <span class="n">apz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">apz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                  <span class="k">call </span><span class="n">compute_diff_wallflux</span><span class="p">(</span><span class="n">divdiff</span><span class="p">(:,</span><span class="n">iwall</span><span class="p">),</span> <span class="n">dxinv</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">q</span><span class="p">,</span> <span class="n">qlo</span><span class="p">,</span> <span class="n">qhi</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">bcent</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">apx</span><span class="p">,</span> <span class="n">axlo</span><span class="p">,</span> <span class="n">axhi</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">apy</span><span class="p">,</span> <span class="n">aylo</span><span class="p">,</span> <span class="n">ayhi</span><span class="p">,</span> <span class="p">&amp;</span>
                       <span class="n">apz</span><span class="p">,</span> <span class="n">azlo</span><span class="p">,</span> <span class="n">azhi</span><span class="p">)</span>
               <span class="k">end if</span>

<span class="k">               </span><span class="n">divwn</span> <span class="o">=</span> <span class="n">divhyp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">iwall</span><span class="p">)</span> <span class="o">+</span> <span class="n">divdiff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">iwall</span><span class="p">)</span>

               <span class="c">! we assume dx == dy == dz</span>
               <span class="n">divc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="n">apx</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">fxp</span> <span class="o">-</span> <span class="n">apx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">fxm</span><span class="p">)</span> <span class="o">*</span> <span class="n">dxinv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">&amp;</span>
                    <span class="o">+</span>          <span class="p">(</span><span class="n">apy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">fyp</span> <span class="o">-</span> <span class="n">apy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">fym</span><span class="p">)</span> <span class="o">*</span> <span class="n">dxinv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">&amp;</span>
                    <span class="o">+</span>          <span class="p">(</span><span class="n">apz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fzp</span> <span class="o">-</span> <span class="n">apz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">fzm</span><span class="p">)</span> <span class="o">*</span> <span class="n">dxinv</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">&amp;</span>
                    <span class="o">+</span>          <span class="n">divwn</span> <span class="o">*</span> <span class="n">dxinv</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">vfrac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
            <span class="k">end if</span>
<span class="k">         end do</span>
<span class="k">      end do</span>
<span class="k">   end do</span>
</pre></div>
</div>
<p>One can easily identify the logic and portions of the code devoted toward the
EB corrections. Note, in particular, that diffusive fluxes into the EB need
only be computed on cut cells.</p>
</div>
<div class="section" id="there-are-many-approaches">
<h3>There are many approaches<a class="headerlink" href="#there-are-many-approaches" title="Permalink to this headline">¶</a></h3>
<p>The “fixes” that need to occur in these EB algorithms can be managed in a
number of ways, depending on the needs of the application and programming
style. In this example, the geometrical data is used to fill dense data
structures so that the sparse geometry information is available uniformally
over the entire box.  Also, the cell types are queried point-by-point in order
to form the appropriate stencil. Obviously then there is a performance penalty
if many of the cells in tile are not actually cut. There is clearly a trade-off
in such designs. Alternatively, one might build sparse data structures similar
to those AMReX uses to manage particles, and apply the EB corrections on this
sparse set directly. Future releases of AMReX will feature an expanded set of
EB tutorials to demonstrate an evolving set of tools provided.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Chapter11.html" class="btn btn-neutral float-right" title="Visualization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Chapter10.html" class="btn btn-neutral" title="Embedded Boundaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, AMReX Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'18.09-dev',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>